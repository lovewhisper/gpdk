<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<title>gpdk.routing.fanout.h_fanout API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="../../assets/10up-sanitize.css/11.0.1/sanitize.min.css">
<link rel="preload stylesheet" as="style" href="../../assets/10up-sanitize.css/11.0.1/typography.min.css">
<link rel="stylesheet preload" as="style" href="../../assets/highlight.js/10.1.1/styles/github-dark.min.css">
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="../../assets/highlight.js/10.1.1/highlight.min.js"></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gpdk.routing.fanout.h_fanout</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from dataclasses import dataclass
from typing import Callable, List, Optional, Sequence, Tuple, cast

from fnpcell import all as fp
from gpdk.components.sbend.sbend import SBendPair
from gpdk.components.straight.straight import Straight
from gpdk.technology import get_technology
from gpdk.util import all as util


@fp.pcell_class()
@dataclass(eq=False)
class HFanout(fp.PCell):
    &#34;&#34;&#34;
    Attributes:
    device: device whose ports need fanout
    left_spacing: spacing between left ports
    right_spacing: spacing between right ports
    bend_degrees: defaults to 30 degrees
    bend_factories: a callable which receives an `IWaveguideType` and returns an `IBendWaveguideFactory`
    device_left_ports: Optional, device left ports from top to bottom
    device_right_ports: Optional, device right ports from bottom to top
    left_distance: Optional
    right_distance: Optional
    left_ports: Optional, port options for left ports
    right_ports: Optional, port options for right ports
    left_waveguide_type: Optional, type of left waveguide
    right_waveguide_type: Optional, type of right waveguide
    connect_length: defaults to 10, distance between generated port and sbend

    Examples:
    ```python
    from gpdk.technology.bend_factory import EulerBendFactory

    def bend_factories(waveguide_type: fp.IWaveguideType):
        if waveguide_type == TECH.WG.FWG.C.WIRE:
            return EulerBendFactory(radius_min=15, l_max=15, waveguide_type=waveguide_type)
        return waveguide_type.bend_factory

    device = HFanout(device=Mmi(waveguide_type=TECH.WG.FWG.C.WIRE), left_spacing=120, right_spacing=120, left_distance=100, right_distance=100,
                bend_factories=bend_factories, left_waveguide_type=TECH.WG.SWG.C.WIRE, right_waveguide_type=TECH.WG.SWG.C.WIRE)
    fp.plot(device)
    ```
    ![HFanout](images/h_fanout.png)
    &#34;&#34;&#34;

    device: fp.IDevice = fp.DeviceParam().as_field()
    left_spacing: float = fp.PositiveFloatParam().as_field()
    right_spacing: float = fp.PositiveFloatParam().as_field()
    bend_degrees: float = fp.DegreeParam(default=30, min=0, max=90, invalid=[0]).as_field()
    bend_factories: Optional[Callable[[fp.IWaveguideType], fp.IBendWaveguideFactory]] = fp.Param(required=False).as_field()
    device_left_ports: Sequence[str] = fp.NameListParam(required=False, doc=&#34;device left ports from top to bottom&#34;).as_field()
    device_right_ports: Sequence[str] = fp.NameListParam(required=False, doc=&#34;device right ports from bottom to top&#34;).as_field()
    left_distance: Optional[float] = fp.FloatParam(required=False, min=0).as_field()
    right_distance: Optional[float] = fp.FloatParam(required=False, min=0).as_field()
    left_ports: Optional[fp.IPortOptions] = fp.PortOptionsParam(required=False).as_field()
    right_ports: Optional[fp.IPortOptions] = fp.PortOptionsParam(required=False).as_field()
    left_waveguide_type: Optional[fp.IWaveguideType] = fp.WaveguideTypeParam(required=False).as_field()
    right_waveguide_type: Optional[fp.IWaveguideType] = fp.WaveguideTypeParam(required=False).as_field()
    connect_length: float = fp.PositiveFloatParam(default=10).as_field()

    def build(self) -&gt; Tuple[fp.InstanceSet, fp.ElementSet, fp.PortSet]:
        insts, elems, ports = super().build()
        TECH = get_technology()

        device = self.device
        left_spacing = self.left_spacing
        right_spacing = self.right_spacing
        bend_degrees = self.bend_degrees
        bend_factories = self.bend_factories
        device_left_ports = self.device_left_ports
        device_right_ports = self.device_right_ports
        left_distance = self.left_distance
        right_distance = self.right_distance
        left_ports = self.left_ports
        right_ports = self.right_ports
        left_waveguide_type = self.left_waveguide_type
        right_waveguide_type = self.right_waveguide_type
        connect_length = self.connect_length
        if device_left_ports is None:
            device_left_ports = cast(List[str], [port.name for port in util.ports.get_left_ports(device)])
        device_left_ports = list(device_left_ports)
        if device_right_ports is None:
            device_right_ports = cast(List[str], [port.name for port in util.ports.get_right_ports(device, reverse=True)])
        device_right_ports = list(device_right_ports)
        left_ports = left_ports or device_left_ports
        right_ports = right_ports or device_right_ports

        result_left_ports: List[fp.IOwnedTerminal] = []
        left_joints: List[Tuple[fp.IOwnedTerminal, fp.IOwnedTerminal]] = []

        left_count = len(device_left_ports)
        assert len(left_ports) == left_count, &#34;len(left_ports) must be equal to len(device_left_ports)&#34;

        for i in range(left_count // 2):
            device_ltop_port = cast(fp.IOwnedPort, device[device_left_ports[i]])
            ltop_port = device_ltop_port

            device_lbottom_port = cast(fp.IOwnedPort, device[device_left_ports[left_count - i - 1]])
            lbottom_port = device_lbottom_port

            ltop_distance = left_distance
            lbottom_distance = left_distance

            if ltop_distance:
                ltop_distance -= connect_length * 2
            if lbottom_distance:
                lbottom_distance -= connect_length * 2

            ltop_transition = None
            lbottom_transition = None
            if left_waveguide_type:
                if ltop_port.waveguide_type != left_waveguide_type:
                    assert ltop_distance, &#34;left_distance is required for auto transition&#34;
                    ltop_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[ltop_port.waveguide_type &gt;&gt; left_waveguide_type]
                    ltop_distance -= fp.distance_between(ltop_transition[port_in].position, ltop_transition[port_out].position)

                if lbottom_port.waveguide_type != left_waveguide_type:
                    assert lbottom_distance, &#34;left_distance is required for auto transition&#34;
                    lbottom_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[lbottom_port.waveguide_type &gt;&gt; left_waveguide_type]
                    lbottom_distance -= fp.distance_between(lbottom_transition[port_in].position, lbottom_transition[port_out].position)
            lconnect_top1 = Straight(
                name=&#34;lctop1&#34;,
                length=connect_length,
                waveguide_type=ltop_port.waveguide_type,
            )
            lconnect_top2 = Straight(
                name=&#34;lctop2&#34;,
                length=connect_length,
                waveguide_type=ltop_port.waveguide_type,
            )
            lconnect_bottom1 = Straight(
                name=&#34;lcbottom1&#34;,
                length=connect_length,
                waveguide_type=lbottom_port.waveguide_type,
            )
            lconnect_bottom2 = Straight(
                name=&#34;lcbottom2&#34;,
                length=connect_length,
                waveguide_type=lbottom_port.waveguide_type,
            )
            ltop_sbend, lbottom_sbend = SBendPair(
                top_distance=ltop_distance,
                bottom_distance=lbottom_distance,
                left_spacing=left_spacing * (left_count - i * 2 - 1),
                right_spacing=fp.distance_between(ltop_port.position, lbottom_port.position),
                bend_degrees=bend_degrees,
                top_type=ltop_port.waveguide_type,
                bottom_type=lbottom_port.waveguide_type,
                top_bend_factory=bend_factories and bend_factories(ltop_port.waveguide_type),
                bottom_bend_factory=bend_factories and bend_factories(lbottom_port.waveguide_type),
            )
            left_joints.append(ltop_port &lt;= lconnect_top1[&#34;op_1&#34;])
            left_joints.append(lconnect_top1[&#34;op_0&#34;] &lt;= ltop_sbend[&#34;op_1&#34;])
            left_joints.append(ltop_sbend[&#34;op_0&#34;] &lt;= lconnect_top2[&#34;op_1&#34;])
            ltop_port = lconnect_top2[&#34;op_0&#34;]
            left_joints.append(lbottom_port &lt;= lconnect_bottom1[&#34;op_1&#34;])
            left_joints.append(lconnect_bottom1[&#34;op_0&#34;] &lt;= lbottom_sbend[&#34;op_1&#34;])
            left_joints.append(lbottom_sbend[&#34;op_0&#34;] &lt;= lconnect_bottom2[&#34;op_1&#34;])
            lbottom_port = lconnect_bottom2[&#34;op_0&#34;]

            if ltop_transition:
                left_joints.append(ltop_port &lt;= ltop_transition[&#34;op_0&#34;])
                ltop_port = ltop_transition[&#34;op_1&#34;]
            if lbottom_transition:
                left_joints.append(lbottom_port &lt;= lbottom_transition[&#34;op_0&#34;])
                lbottom_port = lbottom_transition[&#34;op_1&#34;]

            result_left_ports.insert(0, ltop_port)
            result_left_ports.append(lbottom_port)

            if not left_distance:
                left_distance = abs(ltop_port.position[0] - device_ltop_port.position[0])

        if left_distance and left_count % 2:
            lindex = left_count // 2
            lmiddle_port = cast(fp.IOwnedPort, device[device_left_ports[lindex]])

            lmiddle_distance = left_distance
            lmiddle_transition = None
            if left_waveguide_type and lmiddle_port.waveguide_type != left_waveguide_type:
                assert lmiddle_distance, &#34;middle_distance is required for auto transition&#34;
                lmiddle_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[lmiddle_port.waveguide_type &gt;&gt; left_waveguide_type]
                lmiddle_distance -= fp.distance_between(lmiddle_transition[port_in].position, lmiddle_transition[port_out].position)

            lstraight = Straight(
                name=&#34;lmiddle&#34;,
                length=lmiddle_distance,
                waveguide_type=lmiddle_port.waveguide_type,
            )
            left_joints.append(lmiddle_port &lt;= lstraight[&#34;op_1&#34;])
            lmiddle_port = lstraight[&#34;op_0&#34;]

            if lmiddle_transition:
                left_joints.append(lmiddle_port &lt;= lmiddle_transition[&#34;op_0&#34;])
                lmiddle_port = lmiddle_transition[&#34;op_1&#34;]

            result_left_ports.insert(lindex, lmiddle_port)

        ############################

        result_right_ports: List[fp.IOwnedTerminal] = []
        right_joints: List[Tuple[fp.IOwnedTerminal, fp.IOwnedTerminal]] = []

        right_count = len(device_right_ports)
        assert len(right_ports) == right_count, &#34;len(right_ports) must be equal to len(device_right_ports)&#34;

        for i in range(right_count // 2):
            device_rbottom_port = cast(fp.IOwnedPort, device[device_right_ports[i]])
            rbottom_port = device_rbottom_port
            device_rtop_port = cast(fp.IOwnedPort, device[device_right_ports[right_count - i - 1]])
            rtop_port = device_rtop_port

            rbottom_distance = right_distance
            rtop_distance = right_distance

            if rbottom_distance:
                rbottom_distance -= connect_length * 2
            if rtop_distance:
                rtop_distance -= connect_length * 2

            rbottom_transition = None
            rtop_transition = None
            if right_waveguide_type:
                if rbottom_port.waveguide_type != right_waveguide_type:
                    assert rbottom_distance, &#34;right_distance is required for auto transition&#34;
                    rbottom_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[rbottom_port.waveguide_type &gt;&gt; right_waveguide_type]
                    rbottom_distance -= fp.distance_between(rbottom_transition[port_in].position, rbottom_transition[port_out].position)
                if rtop_port.waveguide_type != right_waveguide_type:
                    assert rtop_distance, &#34;right_distance is required for auto transition&#34;
                    rtop_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[rtop_port.waveguide_type &gt;&gt; right_waveguide_type]
                    rtop_distance -= fp.distance_between(rtop_transition[port_in].position, rtop_transition[port_out].position)
            rconnect_top1 = Straight(
                name=&#34;rctop1&#34;,
                length=connect_length,
                waveguide_type=rtop_port.waveguide_type,
            )
            rconnect_top2 = Straight(
                name=&#34;rctop2&#34;,
                length=connect_length,
                waveguide_type=rtop_port.waveguide_type,
            )
            rconnect_bottom1 = Straight(
                name=&#34;rcbottom1&#34;,
                length=connect_length,
                waveguide_type=rbottom_port.waveguide_type,
            )
            rconnect_bottom2 = Straight(
                name=&#34;rcbottom2&#34;,
                length=connect_length,
                waveguide_type=rbottom_port.waveguide_type,
            )
            rtop_sbend, rbottom_sbend = SBendPair(
                top_distance=rtop_distance,
                bottom_distance=rbottom_distance,
                left_spacing=fp.distance_between(rtop_port.position, rbottom_port.position),
                right_spacing=right_spacing * (right_count - i * 2 - 1),
                bend_degrees=bend_degrees,
                top_type=rtop_port.waveguide_type,
                bottom_type=rbottom_port.waveguide_type,
                top_bend_factory=bend_factories and bend_factories(rtop_port.waveguide_type),
                bottom_bend_factory=bend_factories and bend_factories(rbottom_port.waveguide_type),
            )
            right_joints.append(rbottom_port &lt;= rconnect_bottom1[&#34;op_0&#34;])
            right_joints.append(rconnect_bottom1[&#34;op_1&#34;] &lt;= rbottom_sbend[&#34;op_0&#34;])
            right_joints.append(rbottom_sbend[&#34;op_1&#34;] &lt;= rconnect_bottom2[&#34;op_0&#34;])
            rbottom_port = rconnect_bottom2[&#34;op_1&#34;]
            right_joints.append(rtop_port &lt;= rconnect_top1[&#34;op_0&#34;])
            right_joints.append(rconnect_top1[&#34;op_1&#34;] &lt;= rtop_sbend[&#34;op_0&#34;])
            right_joints.append(rtop_sbend[&#34;op_1&#34;] &lt;= rconnect_top2[&#34;op_0&#34;])
            rtop_port = rconnect_top2[&#34;op_1&#34;]

            if rbottom_transition:
                right_joints.append(rbottom_port &lt;= rbottom_transition[&#34;op_0&#34;])
                rbottom_port = rbottom_transition[&#34;op_1&#34;]
            if rtop_transition:
                right_joints.append(rtop_port &lt;= rtop_transition[&#34;op_0&#34;])
                rtop_port = rtop_transition[&#34;op_1&#34;]

            result_right_ports.insert(0, rbottom_port)
            result_right_ports.append(rtop_port)
            if not right_distance:
                right_distance = abs(rbottom_port.position[0] - device_rbottom_port.position[0])

        if right_distance and right_count % 2:
            rindex = right_count // 2
            rmiddle_port = cast(fp.IOwnedPort, device[device_right_ports[rindex]])

            rmiddle_distance = left_distance
            rmiddle_transition = None
            if right_waveguide_type and rmiddle_port.waveguide_type != right_waveguide_type:
                assert rmiddle_distance, &#34;middle_distance is required for auto transition&#34;
                rmiddle_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[rmiddle_port.waveguide_type &gt;&gt; right_waveguide_type]
                rmiddle_distance -= fp.distance_between(rmiddle_transition[port_in].position, rmiddle_transition[port_out].position)

            rstraight = Straight(
                name=&#34;rmiddle&#34;,
                length=right_distance,
                waveguide_type=rmiddle_port.waveguide_type,
            )
            right_joints.append(rmiddle_port &lt;= rstraight[&#34;op_0&#34;])
            rmiddle_port = rstraight[&#34;op_1&#34;]

            if rmiddle_transition:
                left_joints.append(rmiddle_port &lt;= rmiddle_transition[&#34;op_0&#34;])
                rmiddle_port = rmiddle_transition[&#34;op_1&#34;]

            result_right_ports.insert(rindex, rmiddle_port)

        used_port_names = frozenset((device_left_ports or []) + (device_right_ports or []))
        unused_ports = [port for port in device.ports if port.name not in used_port_names]

        connected = fp.Connected(
            joints=left_joints + right_joints,
            ports=(
                ([port.with_name(left_ports[i]) for i, port in enumerate(result_left_ports)])
                + ([port.with_name(right_ports[i]) for i, port in enumerate(result_right_ports)])
                + unused_ports
            ),
        )
        insts += connected
        ports += connected.ports
        return insts, elems, ports


if __name__ == &#34;__main__&#34;:
    from pathlib import Path

    gds_file = Path(__file__).parent / &#34;local&#34; / Path(__file__).with_suffix(&#34;.gds&#34;).name
    library = fp.Library()

    TECH = get_technology()
    # =============================================================
    # fmt: off
    from gpdk.components.directional_coupler.directional_coupler_sbend import DirectionalCouplerSBend
    from gpdk.components.mmi.mmi import Mmi
    from gpdk.technology.waveguide_factory import EulerBendFactory

    def bend_factories(waveguide_type: fp.IWaveguideType):
        if waveguide_type == TECH.WG.FWG.C.WIRE:
            return EulerBendFactory(radius_min=15, l_max=15, waveguide_type=waveguide_type)
        return waveguide_type.bend_factory

    library += [
            HFanout(
                name=&#34;dc_f0&#34;,
                device=Mmi(waveguide_type=TECH.WG.FWG.C.WIRE),  # for DEMO
                left_spacing=20,
                right_spacing=40,
                left_distance=50,
                right_distance=100,
                bend_degrees=30,
                device_left_ports=[&#34;op_0&#34;],
                device_right_ports=[&#34;op_1&#34;],
                # left_ports=[&#34;op_0&#34;, &#34;op_1&#34;, &#34;op_2&#34;, &#34;op_3&#34;],
            ),
            HFanout(
                name=&#34;dc_f1&#34;,
                device=DirectionalCouplerSBend(
                    name=&#34;0&#34;,
                    coupler_length=24,
                    coupler_spacing=2.8,
                    waveguide_type=TECH.WG.FWG.C.WIRE,
                ),  # for DEMO
                left_spacing=20,
                right_spacing=40,
                left_distance=50,
                right_distance=100,
                # bend_degrees=60,
                # radius_eff=7,
                device_left_ports=[
                    &#34;op_0&#34;,
                ],
                device_right_ports=[&#34;op_2&#34;, &#34;op_3&#34;],
                left_waveguide_type=TECH.WG.SWG.C.WIRE,
                right_waveguide_type=TECH.WG.SWG.C.WIRE,
                # ports=[&#34;op_0&#34;, &#34;op_1&#34;, &#34;op_2&#34;, &#34;op_3&#34;],
            ).translated(0, 50),
            HFanout(
                name=&#34;dc_f1&#34;,
                device=DirectionalCouplerSBend(
                    name=&#34;0&#34;,
                    coupler_length=24,
                    coupler_spacing=2.8,
                    waveguide_type=TECH.WG.FWG.C.WIRE,
                ),  # for DEMO
                left_spacing=120,
                right_spacing=120,
                left_distance=100,
                right_distance=100,
                bend_factories=bend_factories,
                device_left_ports=[
                    &#34;op_0&#34;,
                ],
                device_right_ports=[&#34;op_2&#34;, &#34;op_3&#34;],
                left_waveguide_type=TECH.WG.SWG.C.WIRE,
                right_waveguide_type=TECH.WG.SWG.C.WIRE,
            ).translated(0, 150),
            HFanout(
                name=&#34;dc_f1&#34;,
                device=Mmi(waveguide_type=TECH.WG.FWG.C.WIRE),
                left_spacing=120,
                right_spacing=120,
                left_distance=100,
                right_distance=100,
                bend_factories=bend_factories,
                left_waveguide_type=TECH.WG.SWG.C.WIRE,
                right_waveguide_type=TECH.WG.SWG.C.WIRE,
            ).translated(0, 250),
        ]

    # fmt: on
    # =============================================================
    fp.export_gds(library, file=gds_file)
    # fp.plot(library)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gpdk.routing.fanout.h_fanout.HFanout"><code class="flex name class">
<span>class <span class="ident">HFanout</span></span>
<span>(</span><span>name: str = None, bands: Optional[FrozenSet[fnpcell.interfaces.IBand]] = None, patches: Tuple[fnpcell.interfaces.IElement, ...] = (), port_names: Sequence[Union[None, str, fnpcell.interfaces.Hidden]] = (), transform: fnpcell.transform.Affine2D = None, device: fnpcell.interfaces.ICellRef = None, left_spacing: float = None, right_spacing: float = None, bend_degrees: float = 30, bend_factories: Optional[Callable[[fnpcell.interfaces.IWaveguideType], fnpcell.interfaces.IBendWaveguideFactory]] = None, device_left_ports: Sequence[str] = None, device_right_ports: Sequence[str] = None, left_distance: Optional[float] = None, right_distance: Optional[float] = None, left_ports: Optional[Sequence[Union[None, str, fnpcell.interfaces.Hidden]]] = None, right_ports: Optional[Sequence[Union[None, str, fnpcell.interfaces.Hidden]]] = None, left_waveguide_type: Optional[fnpcell.interfaces.IWaveguideType] = None, right_waveguide_type: Optional[fnpcell.interfaces.IWaveguideType] = None, connect_length: float = 10)</span>
</code></dt>
<dd>
<div class="desc"><p>Attributes:
device: device whose ports need fanout
left_spacing: spacing between left ports
right_spacing: spacing between right ports
bend_degrees: defaults to 30 degrees
bend_factories: a callable which receives an <code>IWaveguideType</code> and returns an <code>IBendWaveguideFactory</code>
device_left_ports: Optional, device left ports from top to bottom
device_right_ports: Optional, device right ports from bottom to top
left_distance: Optional
right_distance: Optional
left_ports: Optional, port options for left ports
right_ports: Optional, port options for right ports
left_waveguide_type: Optional, type of left waveguide
right_waveguide_type: Optional, type of right waveguide
connect_length: defaults to 10, distance between generated port and sbend</p>
<p>Examples:</p>
<pre><code class="language-python">from gpdk.technology.bend_factory import EulerBendFactory

def bend_factories(waveguide_type: fp.IWaveguideType):
    if waveguide_type == TECH.WG.FWG.C.WIRE:
        return EulerBendFactory(radius_min=15, l_max=15, waveguide_type=waveguide_type)
    return waveguide_type.bend_factory

device = HFanout(device=Mmi(waveguide_type=TECH.WG.FWG.C.WIRE), left_spacing=120, right_spacing=120, left_distance=100, right_distance=100,
            bend_factories=bend_factories, left_waveguide_type=TECH.WG.SWG.C.WIRE, right_waveguide_type=TECH.WG.SWG.C.WIRE)
fp.plot(device)
</code></pre>
<p><img alt="HFanout" src="images/h_fanout.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HFanout(fp.PCell):
    &#34;&#34;&#34;
    Attributes:
    device: device whose ports need fanout
    left_spacing: spacing between left ports
    right_spacing: spacing between right ports
    bend_degrees: defaults to 30 degrees
    bend_factories: a callable which receives an `IWaveguideType` and returns an `IBendWaveguideFactory`
    device_left_ports: Optional, device left ports from top to bottom
    device_right_ports: Optional, device right ports from bottom to top
    left_distance: Optional
    right_distance: Optional
    left_ports: Optional, port options for left ports
    right_ports: Optional, port options for right ports
    left_waveguide_type: Optional, type of left waveguide
    right_waveguide_type: Optional, type of right waveguide
    connect_length: defaults to 10, distance between generated port and sbend

    Examples:
    ```python
    from gpdk.technology.bend_factory import EulerBendFactory

    def bend_factories(waveguide_type: fp.IWaveguideType):
        if waveguide_type == TECH.WG.FWG.C.WIRE:
            return EulerBendFactory(radius_min=15, l_max=15, waveguide_type=waveguide_type)
        return waveguide_type.bend_factory

    device = HFanout(device=Mmi(waveguide_type=TECH.WG.FWG.C.WIRE), left_spacing=120, right_spacing=120, left_distance=100, right_distance=100,
                bend_factories=bend_factories, left_waveguide_type=TECH.WG.SWG.C.WIRE, right_waveguide_type=TECH.WG.SWG.C.WIRE)
    fp.plot(device)
    ```
    ![HFanout](images/h_fanout.png)
    &#34;&#34;&#34;

    device: fp.IDevice = fp.DeviceParam().as_field()
    left_spacing: float = fp.PositiveFloatParam().as_field()
    right_spacing: float = fp.PositiveFloatParam().as_field()
    bend_degrees: float = fp.DegreeParam(default=30, min=0, max=90, invalid=[0]).as_field()
    bend_factories: Optional[Callable[[fp.IWaveguideType], fp.IBendWaveguideFactory]] = fp.Param(required=False).as_field()
    device_left_ports: Sequence[str] = fp.NameListParam(required=False, doc=&#34;device left ports from top to bottom&#34;).as_field()
    device_right_ports: Sequence[str] = fp.NameListParam(required=False, doc=&#34;device right ports from bottom to top&#34;).as_field()
    left_distance: Optional[float] = fp.FloatParam(required=False, min=0).as_field()
    right_distance: Optional[float] = fp.FloatParam(required=False, min=0).as_field()
    left_ports: Optional[fp.IPortOptions] = fp.PortOptionsParam(required=False).as_field()
    right_ports: Optional[fp.IPortOptions] = fp.PortOptionsParam(required=False).as_field()
    left_waveguide_type: Optional[fp.IWaveguideType] = fp.WaveguideTypeParam(required=False).as_field()
    right_waveguide_type: Optional[fp.IWaveguideType] = fp.WaveguideTypeParam(required=False).as_field()
    connect_length: float = fp.PositiveFloatParam(default=10).as_field()

    def build(self) -&gt; Tuple[fp.InstanceSet, fp.ElementSet, fp.PortSet]:
        insts, elems, ports = super().build()
        TECH = get_technology()

        device = self.device
        left_spacing = self.left_spacing
        right_spacing = self.right_spacing
        bend_degrees = self.bend_degrees
        bend_factories = self.bend_factories
        device_left_ports = self.device_left_ports
        device_right_ports = self.device_right_ports
        left_distance = self.left_distance
        right_distance = self.right_distance
        left_ports = self.left_ports
        right_ports = self.right_ports
        left_waveguide_type = self.left_waveguide_type
        right_waveguide_type = self.right_waveguide_type
        connect_length = self.connect_length
        if device_left_ports is None:
            device_left_ports = cast(List[str], [port.name for port in util.ports.get_left_ports(device)])
        device_left_ports = list(device_left_ports)
        if device_right_ports is None:
            device_right_ports = cast(List[str], [port.name for port in util.ports.get_right_ports(device, reverse=True)])
        device_right_ports = list(device_right_ports)
        left_ports = left_ports or device_left_ports
        right_ports = right_ports or device_right_ports

        result_left_ports: List[fp.IOwnedTerminal] = []
        left_joints: List[Tuple[fp.IOwnedTerminal, fp.IOwnedTerminal]] = []

        left_count = len(device_left_ports)
        assert len(left_ports) == left_count, &#34;len(left_ports) must be equal to len(device_left_ports)&#34;

        for i in range(left_count // 2):
            device_ltop_port = cast(fp.IOwnedPort, device[device_left_ports[i]])
            ltop_port = device_ltop_port

            device_lbottom_port = cast(fp.IOwnedPort, device[device_left_ports[left_count - i - 1]])
            lbottom_port = device_lbottom_port

            ltop_distance = left_distance
            lbottom_distance = left_distance

            if ltop_distance:
                ltop_distance -= connect_length * 2
            if lbottom_distance:
                lbottom_distance -= connect_length * 2

            ltop_transition = None
            lbottom_transition = None
            if left_waveguide_type:
                if ltop_port.waveguide_type != left_waveguide_type:
                    assert ltop_distance, &#34;left_distance is required for auto transition&#34;
                    ltop_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[ltop_port.waveguide_type &gt;&gt; left_waveguide_type]
                    ltop_distance -= fp.distance_between(ltop_transition[port_in].position, ltop_transition[port_out].position)

                if lbottom_port.waveguide_type != left_waveguide_type:
                    assert lbottom_distance, &#34;left_distance is required for auto transition&#34;
                    lbottom_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[lbottom_port.waveguide_type &gt;&gt; left_waveguide_type]
                    lbottom_distance -= fp.distance_between(lbottom_transition[port_in].position, lbottom_transition[port_out].position)
            lconnect_top1 = Straight(
                name=&#34;lctop1&#34;,
                length=connect_length,
                waveguide_type=ltop_port.waveguide_type,
            )
            lconnect_top2 = Straight(
                name=&#34;lctop2&#34;,
                length=connect_length,
                waveguide_type=ltop_port.waveguide_type,
            )
            lconnect_bottom1 = Straight(
                name=&#34;lcbottom1&#34;,
                length=connect_length,
                waveguide_type=lbottom_port.waveguide_type,
            )
            lconnect_bottom2 = Straight(
                name=&#34;lcbottom2&#34;,
                length=connect_length,
                waveguide_type=lbottom_port.waveguide_type,
            )
            ltop_sbend, lbottom_sbend = SBendPair(
                top_distance=ltop_distance,
                bottom_distance=lbottom_distance,
                left_spacing=left_spacing * (left_count - i * 2 - 1),
                right_spacing=fp.distance_between(ltop_port.position, lbottom_port.position),
                bend_degrees=bend_degrees,
                top_type=ltop_port.waveguide_type,
                bottom_type=lbottom_port.waveguide_type,
                top_bend_factory=bend_factories and bend_factories(ltop_port.waveguide_type),
                bottom_bend_factory=bend_factories and bend_factories(lbottom_port.waveguide_type),
            )
            left_joints.append(ltop_port &lt;= lconnect_top1[&#34;op_1&#34;])
            left_joints.append(lconnect_top1[&#34;op_0&#34;] &lt;= ltop_sbend[&#34;op_1&#34;])
            left_joints.append(ltop_sbend[&#34;op_0&#34;] &lt;= lconnect_top2[&#34;op_1&#34;])
            ltop_port = lconnect_top2[&#34;op_0&#34;]
            left_joints.append(lbottom_port &lt;= lconnect_bottom1[&#34;op_1&#34;])
            left_joints.append(lconnect_bottom1[&#34;op_0&#34;] &lt;= lbottom_sbend[&#34;op_1&#34;])
            left_joints.append(lbottom_sbend[&#34;op_0&#34;] &lt;= lconnect_bottom2[&#34;op_1&#34;])
            lbottom_port = lconnect_bottom2[&#34;op_0&#34;]

            if ltop_transition:
                left_joints.append(ltop_port &lt;= ltop_transition[&#34;op_0&#34;])
                ltop_port = ltop_transition[&#34;op_1&#34;]
            if lbottom_transition:
                left_joints.append(lbottom_port &lt;= lbottom_transition[&#34;op_0&#34;])
                lbottom_port = lbottom_transition[&#34;op_1&#34;]

            result_left_ports.insert(0, ltop_port)
            result_left_ports.append(lbottom_port)

            if not left_distance:
                left_distance = abs(ltop_port.position[0] - device_ltop_port.position[0])

        if left_distance and left_count % 2:
            lindex = left_count // 2
            lmiddle_port = cast(fp.IOwnedPort, device[device_left_ports[lindex]])

            lmiddle_distance = left_distance
            lmiddle_transition = None
            if left_waveguide_type and lmiddle_port.waveguide_type != left_waveguide_type:
                assert lmiddle_distance, &#34;middle_distance is required for auto transition&#34;
                lmiddle_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[lmiddle_port.waveguide_type &gt;&gt; left_waveguide_type]
                lmiddle_distance -= fp.distance_between(lmiddle_transition[port_in].position, lmiddle_transition[port_out].position)

            lstraight = Straight(
                name=&#34;lmiddle&#34;,
                length=lmiddle_distance,
                waveguide_type=lmiddle_port.waveguide_type,
            )
            left_joints.append(lmiddle_port &lt;= lstraight[&#34;op_1&#34;])
            lmiddle_port = lstraight[&#34;op_0&#34;]

            if lmiddle_transition:
                left_joints.append(lmiddle_port &lt;= lmiddle_transition[&#34;op_0&#34;])
                lmiddle_port = lmiddle_transition[&#34;op_1&#34;]

            result_left_ports.insert(lindex, lmiddle_port)

        ############################

        result_right_ports: List[fp.IOwnedTerminal] = []
        right_joints: List[Tuple[fp.IOwnedTerminal, fp.IOwnedTerminal]] = []

        right_count = len(device_right_ports)
        assert len(right_ports) == right_count, &#34;len(right_ports) must be equal to len(device_right_ports)&#34;

        for i in range(right_count // 2):
            device_rbottom_port = cast(fp.IOwnedPort, device[device_right_ports[i]])
            rbottom_port = device_rbottom_port
            device_rtop_port = cast(fp.IOwnedPort, device[device_right_ports[right_count - i - 1]])
            rtop_port = device_rtop_port

            rbottom_distance = right_distance
            rtop_distance = right_distance

            if rbottom_distance:
                rbottom_distance -= connect_length * 2
            if rtop_distance:
                rtop_distance -= connect_length * 2

            rbottom_transition = None
            rtop_transition = None
            if right_waveguide_type:
                if rbottom_port.waveguide_type != right_waveguide_type:
                    assert rbottom_distance, &#34;right_distance is required for auto transition&#34;
                    rbottom_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[rbottom_port.waveguide_type &gt;&gt; right_waveguide_type]
                    rbottom_distance -= fp.distance_between(rbottom_transition[port_in].position, rbottom_transition[port_out].position)
                if rtop_port.waveguide_type != right_waveguide_type:
                    assert rtop_distance, &#34;right_distance is required for auto transition&#34;
                    rtop_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[rtop_port.waveguide_type &gt;&gt; right_waveguide_type]
                    rtop_distance -= fp.distance_between(rtop_transition[port_in].position, rtop_transition[port_out].position)
            rconnect_top1 = Straight(
                name=&#34;rctop1&#34;,
                length=connect_length,
                waveguide_type=rtop_port.waveguide_type,
            )
            rconnect_top2 = Straight(
                name=&#34;rctop2&#34;,
                length=connect_length,
                waveguide_type=rtop_port.waveguide_type,
            )
            rconnect_bottom1 = Straight(
                name=&#34;rcbottom1&#34;,
                length=connect_length,
                waveguide_type=rbottom_port.waveguide_type,
            )
            rconnect_bottom2 = Straight(
                name=&#34;rcbottom2&#34;,
                length=connect_length,
                waveguide_type=rbottom_port.waveguide_type,
            )
            rtop_sbend, rbottom_sbend = SBendPair(
                top_distance=rtop_distance,
                bottom_distance=rbottom_distance,
                left_spacing=fp.distance_between(rtop_port.position, rbottom_port.position),
                right_spacing=right_spacing * (right_count - i * 2 - 1),
                bend_degrees=bend_degrees,
                top_type=rtop_port.waveguide_type,
                bottom_type=rbottom_port.waveguide_type,
                top_bend_factory=bend_factories and bend_factories(rtop_port.waveguide_type),
                bottom_bend_factory=bend_factories and bend_factories(rbottom_port.waveguide_type),
            )
            right_joints.append(rbottom_port &lt;= rconnect_bottom1[&#34;op_0&#34;])
            right_joints.append(rconnect_bottom1[&#34;op_1&#34;] &lt;= rbottom_sbend[&#34;op_0&#34;])
            right_joints.append(rbottom_sbend[&#34;op_1&#34;] &lt;= rconnect_bottom2[&#34;op_0&#34;])
            rbottom_port = rconnect_bottom2[&#34;op_1&#34;]
            right_joints.append(rtop_port &lt;= rconnect_top1[&#34;op_0&#34;])
            right_joints.append(rconnect_top1[&#34;op_1&#34;] &lt;= rtop_sbend[&#34;op_0&#34;])
            right_joints.append(rtop_sbend[&#34;op_1&#34;] &lt;= rconnect_top2[&#34;op_0&#34;])
            rtop_port = rconnect_top2[&#34;op_1&#34;]

            if rbottom_transition:
                right_joints.append(rbottom_port &lt;= rbottom_transition[&#34;op_0&#34;])
                rbottom_port = rbottom_transition[&#34;op_1&#34;]
            if rtop_transition:
                right_joints.append(rtop_port &lt;= rtop_transition[&#34;op_0&#34;])
                rtop_port = rtop_transition[&#34;op_1&#34;]

            result_right_ports.insert(0, rbottom_port)
            result_right_ports.append(rtop_port)
            if not right_distance:
                right_distance = abs(rbottom_port.position[0] - device_rbottom_port.position[0])

        if right_distance and right_count % 2:
            rindex = right_count // 2
            rmiddle_port = cast(fp.IOwnedPort, device[device_right_ports[rindex]])

            rmiddle_distance = left_distance
            rmiddle_transition = None
            if right_waveguide_type and rmiddle_port.waveguide_type != right_waveguide_type:
                assert rmiddle_distance, &#34;middle_distance is required for auto transition&#34;
                rmiddle_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[rmiddle_port.waveguide_type &gt;&gt; right_waveguide_type]
                rmiddle_distance -= fp.distance_between(rmiddle_transition[port_in].position, rmiddle_transition[port_out].position)

            rstraight = Straight(
                name=&#34;rmiddle&#34;,
                length=right_distance,
                waveguide_type=rmiddle_port.waveguide_type,
            )
            right_joints.append(rmiddle_port &lt;= rstraight[&#34;op_0&#34;])
            rmiddle_port = rstraight[&#34;op_1&#34;]

            if rmiddle_transition:
                left_joints.append(rmiddle_port &lt;= rmiddle_transition[&#34;op_0&#34;])
                rmiddle_port = rmiddle_transition[&#34;op_1&#34;]

            result_right_ports.insert(rindex, rmiddle_port)

        used_port_names = frozenset((device_left_ports or []) + (device_right_ports or []))
        unused_ports = [port for port in device.ports if port.name not in used_port_names]

        connected = fp.Connected(
            joints=left_joints + right_joints,
            ports=(
                ([port.with_name(left_ports[i]) for i, port in enumerate(result_left_ports)])
                + ([port.with_name(right_ports[i]) for i, port in enumerate(result_right_ports)])
                + unused_ports
            ),
        )
        insts += connected
        ports += connected.ports
        return insts, elems, ports</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>fnpcell.pdk.pcell.PCell</li>
<li>fnpcell.cell.cell_ref.CellRef</li>
<li>fnpcell.mixin.transform_mixin.TransformMixin</li>
<li>fnpcell.interfaces.ICellRef</li>
<li>fnpcell.interfaces.IUpdatable</li>
<li>fnpcell.interfaces.IElement</li>
<li>fnpcell.interfaces.IRunnable</li>
<li>fnpcell.interfaces.IAffineTransformable</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.bend_degrees"><code class="name">var <span class="ident">bend_degrees</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.bend_factories"><code class="name">var <span class="ident">bend_factories</span> : Optional[Callable[[fnpcell.interfaces.IWaveguideType], fnpcell.interfaces.IBendWaveguideFactory]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.connect_length"><code class="name">var <span class="ident">connect_length</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.device"><code class="name">var <span class="ident">device</span> : fnpcell.interfaces.ICellRef</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.device_left_ports"><code class="name">var <span class="ident">device_left_ports</span> : Sequence[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.device_right_ports"><code class="name">var <span class="ident">device_right_ports</span> : Sequence[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.left_distance"><code class="name">var <span class="ident">left_distance</span> : Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.left_ports"><code class="name">var <span class="ident">left_ports</span> : Optional[Sequence[Union[None, str, fnpcell.interfaces.Hidden]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.left_spacing"><code class="name">var <span class="ident">left_spacing</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.left_waveguide_type"><code class="name">var <span class="ident">left_waveguide_type</span> : Optional[fnpcell.interfaces.IWaveguideType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.right_distance"><code class="name">var <span class="ident">right_distance</span> : Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.right_ports"><code class="name">var <span class="ident">right_ports</span> : Optional[Sequence[Union[None, str, fnpcell.interfaces.Hidden]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.right_spacing"><code class="name">var <span class="ident">right_spacing</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.right_waveguide_type"><code class="name">var <span class="ident">right_waveguide_type</span> : Optional[fnpcell.interfaces.IWaveguideType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gpdk.routing.fanout.h_fanout.HFanout.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self) ‑> Tuple[fnpcell.pdk.collection.InstanceSet, fnpcell.pdk.collection.ElementSet, fnpcell.pdk.collection.PortSet]</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract method must be implemented to build a pcell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self) -&gt; Tuple[fp.InstanceSet, fp.ElementSet, fp.PortSet]:
    insts, elems, ports = super().build()
    TECH = get_technology()

    device = self.device
    left_spacing = self.left_spacing
    right_spacing = self.right_spacing
    bend_degrees = self.bend_degrees
    bend_factories = self.bend_factories
    device_left_ports = self.device_left_ports
    device_right_ports = self.device_right_ports
    left_distance = self.left_distance
    right_distance = self.right_distance
    left_ports = self.left_ports
    right_ports = self.right_ports
    left_waveguide_type = self.left_waveguide_type
    right_waveguide_type = self.right_waveguide_type
    connect_length = self.connect_length
    if device_left_ports is None:
        device_left_ports = cast(List[str], [port.name for port in util.ports.get_left_ports(device)])
    device_left_ports = list(device_left_ports)
    if device_right_ports is None:
        device_right_ports = cast(List[str], [port.name for port in util.ports.get_right_ports(device, reverse=True)])
    device_right_ports = list(device_right_ports)
    left_ports = left_ports or device_left_ports
    right_ports = right_ports or device_right_ports

    result_left_ports: List[fp.IOwnedTerminal] = []
    left_joints: List[Tuple[fp.IOwnedTerminal, fp.IOwnedTerminal]] = []

    left_count = len(device_left_ports)
    assert len(left_ports) == left_count, &#34;len(left_ports) must be equal to len(device_left_ports)&#34;

    for i in range(left_count // 2):
        device_ltop_port = cast(fp.IOwnedPort, device[device_left_ports[i]])
        ltop_port = device_ltop_port

        device_lbottom_port = cast(fp.IOwnedPort, device[device_left_ports[left_count - i - 1]])
        lbottom_port = device_lbottom_port

        ltop_distance = left_distance
        lbottom_distance = left_distance

        if ltop_distance:
            ltop_distance -= connect_length * 2
        if lbottom_distance:
            lbottom_distance -= connect_length * 2

        ltop_transition = None
        lbottom_transition = None
        if left_waveguide_type:
            if ltop_port.waveguide_type != left_waveguide_type:
                assert ltop_distance, &#34;left_distance is required for auto transition&#34;
                ltop_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[ltop_port.waveguide_type &gt;&gt; left_waveguide_type]
                ltop_distance -= fp.distance_between(ltop_transition[port_in].position, ltop_transition[port_out].position)

            if lbottom_port.waveguide_type != left_waveguide_type:
                assert lbottom_distance, &#34;left_distance is required for auto transition&#34;
                lbottom_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[lbottom_port.waveguide_type &gt;&gt; left_waveguide_type]
                lbottom_distance -= fp.distance_between(lbottom_transition[port_in].position, lbottom_transition[port_out].position)
        lconnect_top1 = Straight(
            name=&#34;lctop1&#34;,
            length=connect_length,
            waveguide_type=ltop_port.waveguide_type,
        )
        lconnect_top2 = Straight(
            name=&#34;lctop2&#34;,
            length=connect_length,
            waveguide_type=ltop_port.waveguide_type,
        )
        lconnect_bottom1 = Straight(
            name=&#34;lcbottom1&#34;,
            length=connect_length,
            waveguide_type=lbottom_port.waveguide_type,
        )
        lconnect_bottom2 = Straight(
            name=&#34;lcbottom2&#34;,
            length=connect_length,
            waveguide_type=lbottom_port.waveguide_type,
        )
        ltop_sbend, lbottom_sbend = SBendPair(
            top_distance=ltop_distance,
            bottom_distance=lbottom_distance,
            left_spacing=left_spacing * (left_count - i * 2 - 1),
            right_spacing=fp.distance_between(ltop_port.position, lbottom_port.position),
            bend_degrees=bend_degrees,
            top_type=ltop_port.waveguide_type,
            bottom_type=lbottom_port.waveguide_type,
            top_bend_factory=bend_factories and bend_factories(ltop_port.waveguide_type),
            bottom_bend_factory=bend_factories and bend_factories(lbottom_port.waveguide_type),
        )
        left_joints.append(ltop_port &lt;= lconnect_top1[&#34;op_1&#34;])
        left_joints.append(lconnect_top1[&#34;op_0&#34;] &lt;= ltop_sbend[&#34;op_1&#34;])
        left_joints.append(ltop_sbend[&#34;op_0&#34;] &lt;= lconnect_top2[&#34;op_1&#34;])
        ltop_port = lconnect_top2[&#34;op_0&#34;]
        left_joints.append(lbottom_port &lt;= lconnect_bottom1[&#34;op_1&#34;])
        left_joints.append(lconnect_bottom1[&#34;op_0&#34;] &lt;= lbottom_sbend[&#34;op_1&#34;])
        left_joints.append(lbottom_sbend[&#34;op_0&#34;] &lt;= lconnect_bottom2[&#34;op_1&#34;])
        lbottom_port = lconnect_bottom2[&#34;op_0&#34;]

        if ltop_transition:
            left_joints.append(ltop_port &lt;= ltop_transition[&#34;op_0&#34;])
            ltop_port = ltop_transition[&#34;op_1&#34;]
        if lbottom_transition:
            left_joints.append(lbottom_port &lt;= lbottom_transition[&#34;op_0&#34;])
            lbottom_port = lbottom_transition[&#34;op_1&#34;]

        result_left_ports.insert(0, ltop_port)
        result_left_ports.append(lbottom_port)

        if not left_distance:
            left_distance = abs(ltop_port.position[0] - device_ltop_port.position[0])

    if left_distance and left_count % 2:
        lindex = left_count // 2
        lmiddle_port = cast(fp.IOwnedPort, device[device_left_ports[lindex]])

        lmiddle_distance = left_distance
        lmiddle_transition = None
        if left_waveguide_type and lmiddle_port.waveguide_type != left_waveguide_type:
            assert lmiddle_distance, &#34;middle_distance is required for auto transition&#34;
            lmiddle_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[lmiddle_port.waveguide_type &gt;&gt; left_waveguide_type]
            lmiddle_distance -= fp.distance_between(lmiddle_transition[port_in].position, lmiddle_transition[port_out].position)

        lstraight = Straight(
            name=&#34;lmiddle&#34;,
            length=lmiddle_distance,
            waveguide_type=lmiddle_port.waveguide_type,
        )
        left_joints.append(lmiddle_port &lt;= lstraight[&#34;op_1&#34;])
        lmiddle_port = lstraight[&#34;op_0&#34;]

        if lmiddle_transition:
            left_joints.append(lmiddle_port &lt;= lmiddle_transition[&#34;op_0&#34;])
            lmiddle_port = lmiddle_transition[&#34;op_1&#34;]

        result_left_ports.insert(lindex, lmiddle_port)

    ############################

    result_right_ports: List[fp.IOwnedTerminal] = []
    right_joints: List[Tuple[fp.IOwnedTerminal, fp.IOwnedTerminal]] = []

    right_count = len(device_right_ports)
    assert len(right_ports) == right_count, &#34;len(right_ports) must be equal to len(device_right_ports)&#34;

    for i in range(right_count // 2):
        device_rbottom_port = cast(fp.IOwnedPort, device[device_right_ports[i]])
        rbottom_port = device_rbottom_port
        device_rtop_port = cast(fp.IOwnedPort, device[device_right_ports[right_count - i - 1]])
        rtop_port = device_rtop_port

        rbottom_distance = right_distance
        rtop_distance = right_distance

        if rbottom_distance:
            rbottom_distance -= connect_length * 2
        if rtop_distance:
            rtop_distance -= connect_length * 2

        rbottom_transition = None
        rtop_transition = None
        if right_waveguide_type:
            if rbottom_port.waveguide_type != right_waveguide_type:
                assert rbottom_distance, &#34;right_distance is required for auto transition&#34;
                rbottom_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[rbottom_port.waveguide_type &gt;&gt; right_waveguide_type]
                rbottom_distance -= fp.distance_between(rbottom_transition[port_in].position, rbottom_transition[port_out].position)
            if rtop_port.waveguide_type != right_waveguide_type:
                assert rtop_distance, &#34;right_distance is required for auto transition&#34;
                rtop_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[rtop_port.waveguide_type &gt;&gt; right_waveguide_type]
                rtop_distance -= fp.distance_between(rtop_transition[port_in].position, rtop_transition[port_out].position)
        rconnect_top1 = Straight(
            name=&#34;rctop1&#34;,
            length=connect_length,
            waveguide_type=rtop_port.waveguide_type,
        )
        rconnect_top2 = Straight(
            name=&#34;rctop2&#34;,
            length=connect_length,
            waveguide_type=rtop_port.waveguide_type,
        )
        rconnect_bottom1 = Straight(
            name=&#34;rcbottom1&#34;,
            length=connect_length,
            waveguide_type=rbottom_port.waveguide_type,
        )
        rconnect_bottom2 = Straight(
            name=&#34;rcbottom2&#34;,
            length=connect_length,
            waveguide_type=rbottom_port.waveguide_type,
        )
        rtop_sbend, rbottom_sbend = SBendPair(
            top_distance=rtop_distance,
            bottom_distance=rbottom_distance,
            left_spacing=fp.distance_between(rtop_port.position, rbottom_port.position),
            right_spacing=right_spacing * (right_count - i * 2 - 1),
            bend_degrees=bend_degrees,
            top_type=rtop_port.waveguide_type,
            bottom_type=rbottom_port.waveguide_type,
            top_bend_factory=bend_factories and bend_factories(rtop_port.waveguide_type),
            bottom_bend_factory=bend_factories and bend_factories(rbottom_port.waveguide_type),
        )
        right_joints.append(rbottom_port &lt;= rconnect_bottom1[&#34;op_0&#34;])
        right_joints.append(rconnect_bottom1[&#34;op_1&#34;] &lt;= rbottom_sbend[&#34;op_0&#34;])
        right_joints.append(rbottom_sbend[&#34;op_1&#34;] &lt;= rconnect_bottom2[&#34;op_0&#34;])
        rbottom_port = rconnect_bottom2[&#34;op_1&#34;]
        right_joints.append(rtop_port &lt;= rconnect_top1[&#34;op_0&#34;])
        right_joints.append(rconnect_top1[&#34;op_1&#34;] &lt;= rtop_sbend[&#34;op_0&#34;])
        right_joints.append(rtop_sbend[&#34;op_1&#34;] &lt;= rconnect_top2[&#34;op_0&#34;])
        rtop_port = rconnect_top2[&#34;op_1&#34;]

        if rbottom_transition:
            right_joints.append(rbottom_port &lt;= rbottom_transition[&#34;op_0&#34;])
            rbottom_port = rbottom_transition[&#34;op_1&#34;]
        if rtop_transition:
            right_joints.append(rtop_port &lt;= rtop_transition[&#34;op_0&#34;])
            rtop_port = rtop_transition[&#34;op_1&#34;]

        result_right_ports.insert(0, rbottom_port)
        result_right_ports.append(rtop_port)
        if not right_distance:
            right_distance = abs(rbottom_port.position[0] - device_rbottom_port.position[0])

    if right_distance and right_count % 2:
        rindex = right_count // 2
        rmiddle_port = cast(fp.IOwnedPort, device[device_right_ports[rindex]])

        rmiddle_distance = left_distance
        rmiddle_transition = None
        if right_waveguide_type and rmiddle_port.waveguide_type != right_waveguide_type:
            assert rmiddle_distance, &#34;middle_distance is required for auto transition&#34;
            rmiddle_transition, (port_in, port_out) = TECH.AUTO_TRANSITION.DEFAULT[rmiddle_port.waveguide_type &gt;&gt; right_waveguide_type]
            rmiddle_distance -= fp.distance_between(rmiddle_transition[port_in].position, rmiddle_transition[port_out].position)

        rstraight = Straight(
            name=&#34;rmiddle&#34;,
            length=right_distance,
            waveguide_type=rmiddle_port.waveguide_type,
        )
        right_joints.append(rmiddle_port &lt;= rstraight[&#34;op_0&#34;])
        rmiddle_port = rstraight[&#34;op_1&#34;]

        if rmiddle_transition:
            left_joints.append(rmiddle_port &lt;= rmiddle_transition[&#34;op_0&#34;])
            rmiddle_port = rmiddle_transition[&#34;op_1&#34;]

        result_right_ports.insert(rindex, rmiddle_port)

    used_port_names = frozenset((device_left_ports or []) + (device_right_ports or []))
    unused_ports = [port for port in device.ports if port.name not in used_port_names]

    connected = fp.Connected(
        joints=left_joints + right_joints,
        ports=(
            ([port.with_name(left_ports[i]) for i, port in enumerate(result_left_ports)])
            + ([port.with_name(right_ports[i]) for i, port in enumerate(result_right_ports)])
            + unused_ports
        ),
    )
    insts += connected
    ports += connected.ports
    return insts, elems, ports</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="../../assets/tingle/0.15.3/tingle.min.css">
<script src="../../assets/tingle/0.15.3/tingle.min.js"></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gpdk.routing.fanout" href="index.html">gpdk.routing.fanout</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gpdk.routing.fanout.h_fanout.HFanout" href="#gpdk.routing.fanout.h_fanout.HFanout">HFanout</a></code></h4>
<ul class="">
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.bend_degrees" href="#gpdk.routing.fanout.h_fanout.HFanout.bend_degrees">bend_degrees</a></code></li>
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.bend_factories" href="#gpdk.routing.fanout.h_fanout.HFanout.bend_factories">bend_factories</a></code></li>
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.build" href="#gpdk.routing.fanout.h_fanout.HFanout.build">build</a></code></li>
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.connect_length" href="#gpdk.routing.fanout.h_fanout.HFanout.connect_length">connect_length</a></code></li>
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.device" href="#gpdk.routing.fanout.h_fanout.HFanout.device">device</a></code></li>
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.device_left_ports" href="#gpdk.routing.fanout.h_fanout.HFanout.device_left_ports">device_left_ports</a></code></li>
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.device_right_ports" href="#gpdk.routing.fanout.h_fanout.HFanout.device_right_ports">device_right_ports</a></code></li>
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.left_distance" href="#gpdk.routing.fanout.h_fanout.HFanout.left_distance">left_distance</a></code></li>
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.left_ports" href="#gpdk.routing.fanout.h_fanout.HFanout.left_ports">left_ports</a></code></li>
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.left_spacing" href="#gpdk.routing.fanout.h_fanout.HFanout.left_spacing">left_spacing</a></code></li>
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.left_waveguide_type" href="#gpdk.routing.fanout.h_fanout.HFanout.left_waveguide_type">left_waveguide_type</a></code></li>
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.right_distance" href="#gpdk.routing.fanout.h_fanout.HFanout.right_distance">right_distance</a></code></li>
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.right_ports" href="#gpdk.routing.fanout.h_fanout.HFanout.right_ports">right_ports</a></code></li>
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.right_spacing" href="#gpdk.routing.fanout.h_fanout.HFanout.right_spacing">right_spacing</a></code></li>
<li><code><a title="gpdk.routing.fanout.h_fanout.HFanout.right_waveguide_type" href="#gpdk.routing.fanout.h_fanout.HFanout.right_waveguide_type">right_waveguide_type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
</footer>
</body>
</html>