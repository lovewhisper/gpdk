<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<title>gpdk.routing.comp_scan.comp_scan API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="../../assets/10up-sanitize.css/11.0.1/sanitize.min.css">
<link rel="preload stylesheet" as="style" href="../../assets/10up-sanitize.css/11.0.1/typography.min.css">
<link rel="stylesheet preload" as="style" href="../../assets/highlight.js/10.1.1/styles/github-dark.min.css">
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="../../assets/highlight.js/10.1.1/highlight.min.js"></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gpdk.routing.comp_scan.comp_scan</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import math
from dataclasses import dataclass
from functools import partial
from typing import Any, Callable, Iterable, List, Optional, Protocol, Sequence, Tuple, cast

from fnpcell import all as fp
from gpdk.components.sbend.sbend import SBend
from gpdk.components.straight.straight import Straight
from gpdk.routing.auto_transitioned.auto_transitioned import AutoTransitioned
from gpdk.routing.extended.extended import Extended
from gpdk.technology import get_technology
from gpdk.util import all as util


class DeviceAdapter(Protocol):
    def __call__(self, device: fp.IDevice) -&gt; fp.IDevice:
        ...


class FiberCouplerFactory(Protocol):
    def __call__(self, at: fp.IRay, device: fp.IDevice) -&gt; Tuple[fp.IDevice, str]:
        ...


class ConstFiberCouplerFactory(FiberCouplerFactory):
    def __init__(self, coupler: fp.IDevice, port: Optional[str]):
        self.coupler = coupler
        self.port = port

    def __call__(self, at: fp.IRay, device: fp.IDevice) -&gt; Tuple[fp.IDevice, str]:
        coupler = self.coupler
        port = self.port or &#34;op_0&#34;
        return (coupler, port)


class Block:
    def __init__(
        self,
        content: fp.ICellRef,
        *,
        offset: Tuple[float, float] = (0, 0),
        repeat: int = 1,
        bend_factory: Optional[fp.IBendWaveguideFactory] = None,
        bend_factories: Optional[Callable[[fp.IWaveguideType], fp.IBendWaveguideFactory]] = None,
    ) -&gt; None:
        self.content = content
        self.offset = offset
        self.repeat = repeat
        self.bend_factory = bend_factory
        self.bend_factories = bend_factories


class Alignment(Block):
    def __init__(
        self,
        *,
        offset: Tuple[float, float] = (0, 0),
        waveguide_type: fp.IWaveguideType,
    ) -&gt; None:

        super().__init__(
            content=fp.Device(
                name=&#34;Alignment&#34;,
                content=[],
                ports=[
                    fp.Port(name=&#34;op_0&#34;, position=(0, 0), orientation=0, waveguide_type=waveguide_type),
                    fp.Port(name=&#34;op_1&#34;, position=(0, 0), orientation=math.pi, waveguide_type=waveguide_type),
                ],
            ),
            offset=offset,
        )


class Title(Block):
    def __init__(
        self,
        content: str,
        *,
        gap: float = 20,
        font_size: float = 5,
        layer: fp.ILayer,
    ) -&gt; None:
        super().__init__(
            content=fp.Device(
                name=&#34;Title&#34;,
                content=[
                    fp.el.Label(
                        content,
                        font_size=font_size,
                        layer=layer,
                    ),
                ],
                ports=[],
            ),
        )
        self.gap = gap


class Blank(Block):
    def __init__(
        self,
        *,
        left: int = 1,
        right: int = 1,
    ) -&gt; None:
        super().__init__(
            content=fp.Device(name=&#34;Blank&#34;, content=[], ports=[]),
        )
        self.left = left
        self.right = right


def _get_ports_center_y(ports: Iterable[fp.IPort]):
    ys = tuple(p.position[1] for p in ports)
    return (min(ys) + max(ys)) / 2


def _get_block_content(block: Block, left_y: float, right_y: float, spacing: float, device_adapter: DeviceAdapter):
    SHORT_STRAIGHT = 1
    ox, oy = block.offset

    device = block.content
    left_ports = util.ports.get_left_ports(device, reverse=True)
    right_ports = util.ports.get_right_ports(device, reverse=True)
    center_y = _get_ports_center_y(left_ports + right_ports)
    left_y2 = left_y + (len(left_ports) - 1) * spacing
    right_y2 = right_y + (len(right_ports) - 1) * spacing

    y = (min(left_y, right_y) + max(left_y2, right_y2)) / 2 - center_y

    if block.repeat &gt; 1:
        prev = device
        joints: List[Tuple[fp.IOwnedTerminal, fp.IOwnedTerminal]] = []
        for _ in range(1, block.repeat):
            curr = prev.h_mirrored()  # device.h_mirrored() if i % 2 else device.translated(0, 0)
            right_ports = util.ports.get_right_ports(prev, reverse=True)
            left_ports = util.ports.get_left_ports(curr, reverse=True)
            for a, b in zip(right_ports, left_ports):
                s = Straight(length=SHORT_STRAIGHT, waveguide_type=a.waveguide_type)
                joints.append(a &lt;= s[&#34;op_0&#34;])
                joints.append(s[&#34;op_1&#34;] &lt;= b)
            prev = curr

        left_ports = util.ports.get_left_ports(device, reverse=True)
        right_ports = list(util.ports.get_right_ports(prev, reverse=False))
        ports = [port.with_name(f&#34;op_{i}&#34;) for i, port in enumerate(left_ports + right_ports)]
        distance = fp.distance_between(left_ports[0].position, right_ports[0].position)
        block_content = fp.Connected(joints=joints, ports=ports)
        tx, ty = -distance / 2 + ox, y + oy
    else:
        block_content = device
        tx, ty = 0 + ox, y + oy

    return device_adapter(device=block_content).translated(tx, ty)


@fp.pcell_class()
@dataclass(eq=False)
class CompScan(fp.PCell):
    &#34;&#34;&#34;
    Attributes:
        max_lines: Optional, max lines, raise error if exceeded
        blocks: blocks of devices
        width: defaults to 2000, total width between grating couplers
        spacing: defaults to 127, spacing between lines
        bend_degrees: defaults to 45, central angle of generated bend
        bend_factory: Optional, will be used to generate all bends if provided
        bend_factories: Optional, providing `IBendWaveguideFactory` for each waveguide type
        waveguide_type: Optional, type of generated waveguide
        connection_type: Optional, type of generated connection straight
        device_connection_length: defaults to 20, minimum distance between device and sbend
        min_io_connection_length: defaults to 20, minimum distance between grating coupler and sbend
    Examples:
    ```python
    TECH = get_technology()
        # ...
    device = CompScan(spacing=255, width=2000, blocks=blocks)
    fp.plot(device)
    ```
    ![CompScan](images/comp_scan.png)
    &#34;&#34;&#34;

    fiber_coupler_factory: FiberCouplerFactory = fp.Param().as_field()
    fiber_coupler_adapter: Optional[fp.IDevice] = fp.DeviceParam(required=False).as_field()
    fiber_coupler_adapter_port: Optional[str] = fp.TextParam(required=False).as_field()
    fiber_coupler_v_mirrored: Sequence[bool] = fp.Param(default=(False, False)).as_field()
    max_lines: Optional[int] = fp.PositiveIntParam(required=False).as_field()
    blocks: Sequence[Block] = fp.ListParam(element_type=Block, immutable=True).as_field()
    width: float = fp.PositiveFloatParam(default=2000).as_field()
    spacing: float = fp.PositiveFloatParam(default=127).as_field()
    bend_degrees: float = fp.DegreeParam(default=45).as_field()
    bend_factory: Optional[fp.IBendWaveguideFactory] = fp.Param(required=False).as_field()
    bend_factories: Optional[Callable[[fp.IWaveguideType], fp.IBendWaveguideFactory]] = fp.Param(required=False).as_field()
    waveguide_type: Optional[fp.IWaveguideType] = fp.WaveguideTypeParam(required=False).as_field()
    connection_type: Optional[fp.IWaveguideType] = fp.WaveguideTypeParam(required=False).as_field()
    device_connection_length: float = fp.PositiveFloatParam(default=20).as_field()
    min_io_connection_length: float = fp.PositiveFloatParam(default=20).as_field()

    def _default_fiber_coupler_factory(self):
        if self.fiber_coupler_adapter is not None:
            return ConstFiberCouplerFactory(self.fiber_coupler_adapter, self.fiber_coupler_adapter_port or &#34;op_0&#34;)

        return None

    def __post_pcell_init__(self):
        assert len(self.fiber_coupler_v_mirrored) == 2, &#34;`fiber_coupler_v_mirrored` must have its length equals to 2&#34;

    def build(self) -&gt; Tuple[fp.InstanceSet, fp.ElementSet, fp.PortSet]:
        insts, elems, ports = super().build()
        TECH = get_technology()
        fiber_coupler_factory = self.fiber_coupler_factory
        left_v_mirrored, right_v_mirrored = self.fiber_coupler_v_mirrored
        max_lines = self.max_lines
        blocks = self.blocks
        width = self.width
        spacing = self.spacing
        bend_degrees = self.bend_degrees
        default_bend_factory = self.bend_factory
        default_bend_factories = self.bend_factories
        waveguide_type = self.waveguide_type
        connection_type = self.connection_type
        device_connection_length = self.device_connection_length
        min_io_connection_length = self.min_io_connection_length

        SHORT_STRAIGHT = 0.1
        content: List[fp.ICellRef] = []
        left_x = -width / 2
        right_x = width / 2
        left_y: float = 0
        right_y: float = 0
        links: List[
            Tuple[
                Tuple[fp.IOwnedPort, fp.IOwnedPort], str, Optional[fp.IBendWaveguideFactory], Optional[Callable[[fp.IWaveguideType], fp.IBendWaveguideFactory]]
            ]
        ] = []
        total_lines = 0

        if connection_type is None:
            connection_type = waveguide_type
        for block in blocks:
            assert isinstance(block, Block)
            y = max(left_y, right_y)
            if isinstance(block, Title):
                label: Any = block.content.cell.content[0]
                distance, _ = label.size
                count = int(width / (distance + block.gap))
                labels: List[fp.IElement] = []
                for i in range(count):
                    labels.append(label.translated(-width / 2 + i * (distance + block.gap), y))
                content.append(fp.Device(name=&#34;Title&#34;, content=labels, ports=[]))
                left_y = y + spacing
                right_y = y + spacing
                continue
            if isinstance(block, Blank):
                left_y += block.left * spacing
                right_y += block.right * spacing
                continue
            block_bend_factory = block.bend_factory
            block_bend_factories = block.bend_factories
            bend_factory = block_bend_factory or default_bend_factory
            bend_factories = block_bend_factories or default_bend_factories

            device_adapter = cast(DeviceAdapter, partial(Extended, waveguide_type=waveguide_type, lengths={&#34;*&#34;: device_connection_length}))
            instance = _get_block_content(block, left_y, right_y, spacing, device_adapter)
            content.append(instance)
            left_ports = util.ports.get_left_ports(instance, reverse=True)
            right_ports = util.ports.get_right_ports(instance, reverse=True)
            for left_port in left_ports:
                left_gc_at = fp.Waypoint(left_x, left_y, 180)
                left_gc, left_gc_port = fiber_coupler_factory(at=left_gc_at, device=instance)
                if left_v_mirrored:
                    left_gc = left_gc.v_mirrored()
                left_gc_instance = left_gc if waveguide_type is None else AutoTransitioned(device=left_gc, waveguide_types={&#34;*&#34;: waveguide_type})
                left_gc_transition_length = fp.distance_between(left_gc[left_gc_port].position, left_gc_instance[left_gc_port].position)
                left_gc_instance = fp.place(left_gc_instance, left_gc_port, at=left_gc_at.advanced(-left_gc_transition_length))
                content.append(left_gc_instance)
                left_y += spacing
                turning_angle = fp.normalize_angle(math.pi - left_port.orientation)
                if fp.is_nonzero(turning_angle):
                    left_port = util.links.bend(
                        TECH,
                        content,
                        start=left_port,
                        radians=turning_angle,
                        bend_factory=bend_factory or bend_factories and bend_factories(left_port.waveguide_type),
                    )
                    left_port = util.links.straight(TECH, content, start=left_port, length=SHORT_STRAIGHT)
                links.append((left_port &lt;= cast(fp.IOwnedPort, left_gc_instance[left_gc_port]), &#34;left&#34;, bend_factory, bend_factories))

            for right_port in right_ports:
                right_gc_at = fp.Waypoint(right_x, right_y, 0)
                right_gc, right_gc_port = fiber_coupler_factory(at=right_gc_at, device=instance)
                if right_v_mirrored:
                    right_gc = right_gc.v_mirrored()
                right_gc_instance = right_gc if waveguide_type is None else AutoTransitioned(device=right_gc, waveguide_types={&#34;*&#34;: waveguide_type})
                right_gc_transition_length = fp.distance_between(right_gc[right_gc_port].position, right_gc_instance[right_gc_port].position)
                right_gc_instance = fp.place(right_gc_instance, right_gc_port, at=right_gc_at.advanced(-right_gc_transition_length))

                content.append(right_gc_instance)
                right_y += spacing
                turning_angle = fp.normalize_angle(0 - right_port.orientation)
                if fp.is_nonzero(turning_angle):
                    right_port = util.links.bend(
                        TECH,
                        content,
                        start=right_port,
                        radians=turning_angle,
                        bend_factory=bend_factory or bend_factories and bend_factories(right_port.waveguide_type),
                    )
                    right_port = util.links.straight(TECH, content, start=right_port, length=SHORT_STRAIGHT)
                links.append((right_port &lt;= cast(fp.IOwnedPort, right_gc_instance[right_gc_port]), &#34;right&#34;, bend_factory, bend_factories))
            total_lines += max(len(left_ports), len(right_ports))

        if max_lines is not None:
            assert total_lines &lt;= max_lines, f&#34;exceed max lines: {max_lines}, got: {total_lines}&#34;

        for (dev, gc), p, bend_factory, bend_factories in links:
            if p == &#34;left&#34;:
                x0, y0 = gc.position
                x1, y1 = dev.position
            else:
                x0, y0 = dev.position
                x1, y1 = gc.position

            length = x1 - x0
            height = y1 - y0

            end_type = waveguide_type
            if fp.is_nonzero(height):
                sbend_type = waveguide_type or dev.waveguide_type
                sbend = SBend(
                    height=height,
                    bend_degrees=bend_degrees,
                    max_distance=length - min_io_connection_length,
                    waveguide_type=sbend_type,
                    bend_factory=bend_factory or (bend_factories and bend_factories(sbend_type)) or sbend_type.bend_factory,
                )
                sbend_distance = abs(sbend[&#34;op_1&#34;].position[0] - sbend[&#34;op_0&#34;].position[0])
                sbend = fp.place(sbend, &#34;op_1&#34; if p == &#34;left&#34; else &#34;op_0&#34;, at=dev.position)
                content.append(sbend)
                length -= sbend_distance
                end_type = sbend_type

            util.links.straight(TECH, content, start=gc, length=length, link_type=connection_type, end_type=end_type)

        insts += content
        return insts, elems, ports


class CompScanBuilder:
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        fiber_coupler_factory: Optional[FiberCouplerFactory] = None,
        fiber_coupler_adapter: Optional[fp.IDevice] = None,
        fiber_coupler_v_mirrored: Sequence[bool] = (False, False),
        max_lines: Optional[int] = None,
        width: float = 2000,
        spacing: float = 127,
        waveguide_type: Optional[fp.IWaveguideType] = None,
        bend_degrees: Optional[float] = None,
        connection_type: Optional[fp.IWaveguideType] = None,
        device_connection_length: float = 20,
        min_io_connection_length: float = 20,
        bend_factory: Optional[fp.IBendWaveguideFactory] = None,
        bend_factories: Optional[Callable[[fp.IWaveguideType], fp.IBendWaveguideFactory]] = None,
    ) -&gt; None:
        self.name = name
        self.fiber_coupler_factory = fiber_coupler_factory
        self.fiber_coupler_adapter = fiber_coupler_adapter
        self.fiber_coupler_v_mirrored = fiber_coupler_v_mirrored
        self.max_lines = max_lines
        self.width = width
        self.spacing = spacing
        self.waveguide_type = waveguide_type
        self.bend_degrees = bend_degrees
        self.connection_type = connection_type
        self.device_connection_length = device_connection_length
        self.min_io_connection_length = min_io_connection_length
        self.bend_factory = bend_factory
        self.bend_factories = bend_factories
        self.blocks = []  # type: List[Block]

    def build(self, transform: fp.Affine2D = fp.Affine2D.identity()):
        params = dict(
            name=self.name or &#34;&#34;,
            fiber_coupler_factory=self.fiber_coupler_factory,
            fiber_coupler_adapter=self.fiber_coupler_adapter,
            fiber_coupler_v_mirrored=self.fiber_coupler_v_mirrored,
            max_lines=self.max_lines,
            blocks=self.blocks,
            width=self.width,
            spacing=self.spacing,
            waveguide_type=self.waveguide_type,
            connection_type=self.connection_type,
            device_connection_length=self.device_connection_length,
            min_io_connection_length=self.min_io_connection_length,
            bend_factory=self.bend_factory,
            bend_factories=self.bend_factories,
            transform=transform,
        )
        for key, value in list(params.items()):
            if value is None:
                del params[key]
        return CompScan(**params)

    def add_block(
        self,
        content: fp.IDevice,
        *,
        offset: Tuple[float, float] = (0, 0),
        repeat: int = 1,
        bend_factory: Optional[fp.IBendWaveguideFactory] = None,
        bend_factories: Optional[Callable[[fp.IWaveguideType], fp.IBendWaveguideFactory]] = None,
    ):
        self.blocks.append(Block(content, offset=offset, repeat=repeat, bend_factory=bend_factory, bend_factories=bend_factories))

    def add_alignment(self, *, offset: Tuple[float, float] = (0, 0), waveguide_type: Optional[fp.IWaveguideType] = None):
        waveguide_type = waveguide_type or self.waveguide_type
        assert waveguide_type is not None, &#34;waveguide_type must be supplied&#34;
        self.blocks.append(Alignment(offset=offset, waveguide_type=waveguide_type))

    def add_title(self, content: str, *, gap: float = 20, font_size: float = 5, layer: fp.ILayer):
        self.blocks.append(Title(content, gap=gap, font_size=font_size, layer=layer))

    def add_blank(self, left: int = 1, right: int = 1):
        self.blocks.append(Blank(left=left, right=right))


if __name__ == &#34;__main__&#34;:
    from pathlib import Path

    gds_file = Path(__file__).parent / &#34;local&#34; / Path(__file__).with_suffix(&#34;.gds&#34;).name
    library = fp.Library()

    TECH = get_technology()
    # =============================================================
    from gpdk.components.fixed_terminator_te_1550.fixed_terminator_te_1550 import Fixed_Terminator_TE_1550
    from gpdk.components.ring_filter.ring_filter import RingFilter
    from gpdk.components.ring_resonator.ring_resonator import RingResonator
    from gpdk.routing.extended.extended import Extended
    from gpdk.technology.waveguide_factory import EulerBendFactory
    from gpdk.components.grating_coupler.grating_coupler import GratingCoupler

    def gc_factory(at: fp.IRay, device: fp.IDevice):
        gc = GratingCoupler()  # type: ignore
        return gc, &#34;op_0&#34;

    def bend_factories(waveguide_type: fp.IWaveguideType):
        if waveguide_type == TECH.WG.FWG.C.WIRE:
            return EulerBendFactory(radius_min=35, l_max=35, waveguide_type=waveguide_type)
        elif waveguide_type == TECH.WG.SWG.C.EXPANDED:
            return EulerBendFactory(radius_min=55, l_max=35, waveguide_type=waveguide_type)
        elif waveguide_type == TECH.WG.SWG.C.WIRE:
            return EulerBendFactory(radius_min=45, l_max=35, waveguide_type=waveguide_type)
        return waveguide_type.bend_factory

    def get_ring_resonator_with_terminator(ring_radius: float):
        terminator = Fixed_Terminator_TE_1550(waveguide_type=TECH.WG.FWG.C.WIRE)
        ring_resonator = RingResonator(ring_radius=ring_radius, ring_type=TECH.WG.FWG.C.WIRE)
        return Extended(
            device=fp.Connected(
                joints=[ring_resonator[&#34;op_2&#34;] &lt;= terminator[&#34;op_0&#34;]], ports=[ring_resonator[&#34;op_0&#34;], ring_resonator[&#34;op_1&#34;], ring_resonator[&#34;op_3&#34;]]
            ),
            lengths={&#34;*&#34;: 20},
        )

    blocks = [
        Alignment(
            waveguide_type=TECH.WG.FWG.C.WIRE,
        ),
        Title(
            &#34;TEST TITLE&#34;,
            layer=TECH.LAYER.LABEL_DRW,
        ),
        Block(get_ring_resonator_with_terminator(25)),
        Blank(left=0, right=1),
        Block(
            get_ring_resonator_with_terminator(50),
            repeat=3,
        ),
        Block(
            get_ring_resonator_with_terminator(75),
            repeat=3,
        ),
        Block(get_ring_resonator_with_terminator(90), bend_factories=bend_factories),
        Blank(left=0, right=1),
        Block(
            RingFilter(
                ring_radius=25,
                waveguide_type=TECH.WG.FWG.C.WIRE,
            )
        ),
        Block(
            RingResonator(ring_radius=90, ring_type=TECH.WG.FWG.C.WIRE),
            repeat=3,
        ),
    ]

    def term_factory(at: fp.IRay, device: fp.IDevice):
        from gpdk.components.fixed_terminator_te_1550.fixed_terminator_te_1550 import Fixed_Terminator_TE_1550

        instance = Fixed_Terminator_TE_1550().h_mirrored()  # type: ignore
        return instance, &#34;op_0&#34;

    library += CompScan(name=&#34;comp_scan&#34;, spacing=255, width=2000, blocks=blocks, fiber_coupler_factory=term_factory)
    library += CompScan(name=&#34;comp_scan&#34;, spacing=255, width=2000, blocks=blocks, fiber_coupler_adapter=Fixed_Terminator_TE_1550())
    library += CompScan(name=&#34;comp_scan&#34;, spacing=255, width=2000, blocks=blocks, bend_factories=bend_factories, fiber_coupler_factory=gc_factory)
    library += CompScan(
        name=&#34;comp_scan&#34;,
        spacing=255,
        width=2000,
        blocks=blocks,
        bend_factories=bend_factories,
        waveguide_type=TECH.WG.SWG.C.EXPANDED,
        bend_factory=TECH.WG.SWG.C.WIRE.bend_factory,
        connection_type=TECH.WG.MWG.C.WIRE,
        fiber_coupler_factory=gc_factory,
    )

    # =============================================================
    fp.export_gds(library, file=gds_file)
    # fp.plot(library)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gpdk.routing.comp_scan.comp_scan.Alignment"><code class="flex name class">
<span>class <span class="ident">Alignment</span></span>
<span>(</span><span>*, offset: Tuple[float, float] = (0, 0), waveguide_type: fnpcell.interfaces.IWaveguideType)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Alignment(Block):
    def __init__(
        self,
        *,
        offset: Tuple[float, float] = (0, 0),
        waveguide_type: fp.IWaveguideType,
    ) -&gt; None:

        super().__init__(
            content=fp.Device(
                name=&#34;Alignment&#34;,
                content=[],
                ports=[
                    fp.Port(name=&#34;op_0&#34;, position=(0, 0), orientation=0, waveguide_type=waveguide_type),
                    fp.Port(name=&#34;op_1&#34;, position=(0, 0), orientation=math.pi, waveguide_type=waveguide_type),
                ],
            ),
            offset=offset,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gpdk.routing.comp_scan.comp_scan.Block" href="#gpdk.routing.comp_scan.comp_scan.Block">Block</a></li>
</ul>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.Blank"><code class="flex name class">
<span>class <span class="ident">Blank</span></span>
<span>(</span><span>*, left: int = 1, right: int = 1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Blank(Block):
    def __init__(
        self,
        *,
        left: int = 1,
        right: int = 1,
    ) -&gt; None:
        super().__init__(
            content=fp.Device(name=&#34;Blank&#34;, content=[], ports=[]),
        )
        self.left = left
        self.right = right</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gpdk.routing.comp_scan.comp_scan.Block" href="#gpdk.routing.comp_scan.comp_scan.Block">Block</a></li>
</ul>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.Block"><code class="flex name class">
<span>class <span class="ident">Block</span></span>
<span>(</span><span>content: fnpcell.interfaces.ICellRef, *, offset: Tuple[float, float] = (0, 0), repeat: int = 1, bend_factory: Optional[fnpcell.interfaces.IBendWaveguideFactory] = None, bend_factories: Optional[Callable[[fnpcell.interfaces.IWaveguideType], fnpcell.interfaces.IBendWaveguideFactory]] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Block:
    def __init__(
        self,
        content: fp.ICellRef,
        *,
        offset: Tuple[float, float] = (0, 0),
        repeat: int = 1,
        bend_factory: Optional[fp.IBendWaveguideFactory] = None,
        bend_factories: Optional[Callable[[fp.IWaveguideType], fp.IBendWaveguideFactory]] = None,
    ) -&gt; None:
        self.content = content
        self.offset = offset
        self.repeat = repeat
        self.bend_factory = bend_factory
        self.bend_factories = bend_factories</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="gpdk.routing.comp_scan.comp_scan.Alignment" href="#gpdk.routing.comp_scan.comp_scan.Alignment">Alignment</a></li>
<li><a title="gpdk.routing.comp_scan.comp_scan.Blank" href="#gpdk.routing.comp_scan.comp_scan.Blank">Blank</a></li>
<li><a title="gpdk.routing.comp_scan.comp_scan.Title" href="#gpdk.routing.comp_scan.comp_scan.Title">Title</a></li>
</ul>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan"><code class="flex name class">
<span>class <span class="ident">CompScan</span></span>
<span>(</span><span>name: str = None, bands: Optional[FrozenSet[fnpcell.interfaces.IBand]] = None, patches: Tuple[fnpcell.interfaces.IElement, ...] = (), port_names: Sequence[Union[None, str, fnpcell.interfaces.Hidden]] = (), transform: fnpcell.transform.Affine2D = None, fiber_coupler_factory: <a title="gpdk.routing.comp_scan.comp_scan.FiberCouplerFactory" href="#gpdk.routing.comp_scan.comp_scan.FiberCouplerFactory">FiberCouplerFactory</a> = None, fiber_coupler_adapter: Optional[fnpcell.interfaces.ICellRef] = None, fiber_coupler_adapter_port: Optional[str] = None, fiber_coupler_v_mirrored: Sequence[bool] = (False, False), max_lines: Optional[int] = None, blocks: Sequence[<a title="gpdk.routing.comp_scan.comp_scan.Block" href="#gpdk.routing.comp_scan.comp_scan.Block">Block</a>] = None, width: float = 2000, spacing: float = 127, bend_degrees: float = 45, bend_factory: Optional[fnpcell.interfaces.IBendWaveguideFactory] = None, bend_factories: Optional[Callable[[fnpcell.interfaces.IWaveguideType], fnpcell.interfaces.IBendWaveguideFactory]] = None, waveguide_type: Optional[fnpcell.interfaces.IWaveguideType] = None, connection_type: Optional[fnpcell.interfaces.IWaveguideType] = None, device_connection_length: float = 20, min_io_connection_length: float = 20)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>max_lines</code></strong></dt>
<dd>Optional, max lines, raise error if exceeded</dd>
<dt><strong><code>blocks</code></strong></dt>
<dd>blocks of devices</dd>
<dt><strong><code>width</code></strong></dt>
<dd>defaults to 2000, total width between grating couplers</dd>
<dt><strong><code>spacing</code></strong></dt>
<dd>defaults to 127, spacing between lines</dd>
<dt><strong><code>bend_degrees</code></strong></dt>
<dd>defaults to 45, central angle of generated bend</dd>
<dt><strong><code>bend_factory</code></strong></dt>
<dd>Optional, will be used to generate all bends if provided</dd>
<dt><strong><code>bend_factories</code></strong></dt>
<dd>Optional, providing <code>IBendWaveguideFactory</code> for each waveguide type</dd>
<dt><strong><code>waveguide_type</code></strong></dt>
<dd>Optional, type of generated waveguide</dd>
<dt><strong><code>connection_type</code></strong></dt>
<dd>Optional, type of generated connection straight</dd>
<dt><strong><code>device_connection_length</code></strong></dt>
<dd>defaults to 20, minimum distance between device and sbend</dd>
<dt><strong><code>min_io_connection_length</code></strong></dt>
<dd>defaults to 20, minimum distance between grating coupler and sbend</dd>
</dl>
<p>Examples:</p>
<pre><code class="language-python">TECH = get_technology()
    # ...
device = CompScan(spacing=255, width=2000, blocks=blocks)
fp.plot(device)
</code></pre>
<p><img alt="CompScan" src="images/comp_scan.png"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompScan(fp.PCell):
    &#34;&#34;&#34;
    Attributes:
        max_lines: Optional, max lines, raise error if exceeded
        blocks: blocks of devices
        width: defaults to 2000, total width between grating couplers
        spacing: defaults to 127, spacing between lines
        bend_degrees: defaults to 45, central angle of generated bend
        bend_factory: Optional, will be used to generate all bends if provided
        bend_factories: Optional, providing `IBendWaveguideFactory` for each waveguide type
        waveguide_type: Optional, type of generated waveguide
        connection_type: Optional, type of generated connection straight
        device_connection_length: defaults to 20, minimum distance between device and sbend
        min_io_connection_length: defaults to 20, minimum distance between grating coupler and sbend
    Examples:
    ```python
    TECH = get_technology()
        # ...
    device = CompScan(spacing=255, width=2000, blocks=blocks)
    fp.plot(device)
    ```
    ![CompScan](images/comp_scan.png)
    &#34;&#34;&#34;

    fiber_coupler_factory: FiberCouplerFactory = fp.Param().as_field()
    fiber_coupler_adapter: Optional[fp.IDevice] = fp.DeviceParam(required=False).as_field()
    fiber_coupler_adapter_port: Optional[str] = fp.TextParam(required=False).as_field()
    fiber_coupler_v_mirrored: Sequence[bool] = fp.Param(default=(False, False)).as_field()
    max_lines: Optional[int] = fp.PositiveIntParam(required=False).as_field()
    blocks: Sequence[Block] = fp.ListParam(element_type=Block, immutable=True).as_field()
    width: float = fp.PositiveFloatParam(default=2000).as_field()
    spacing: float = fp.PositiveFloatParam(default=127).as_field()
    bend_degrees: float = fp.DegreeParam(default=45).as_field()
    bend_factory: Optional[fp.IBendWaveguideFactory] = fp.Param(required=False).as_field()
    bend_factories: Optional[Callable[[fp.IWaveguideType], fp.IBendWaveguideFactory]] = fp.Param(required=False).as_field()
    waveguide_type: Optional[fp.IWaveguideType] = fp.WaveguideTypeParam(required=False).as_field()
    connection_type: Optional[fp.IWaveguideType] = fp.WaveguideTypeParam(required=False).as_field()
    device_connection_length: float = fp.PositiveFloatParam(default=20).as_field()
    min_io_connection_length: float = fp.PositiveFloatParam(default=20).as_field()

    def _default_fiber_coupler_factory(self):
        if self.fiber_coupler_adapter is not None:
            return ConstFiberCouplerFactory(self.fiber_coupler_adapter, self.fiber_coupler_adapter_port or &#34;op_0&#34;)

        return None

    def __post_pcell_init__(self):
        assert len(self.fiber_coupler_v_mirrored) == 2, &#34;`fiber_coupler_v_mirrored` must have its length equals to 2&#34;

    def build(self) -&gt; Tuple[fp.InstanceSet, fp.ElementSet, fp.PortSet]:
        insts, elems, ports = super().build()
        TECH = get_technology()
        fiber_coupler_factory = self.fiber_coupler_factory
        left_v_mirrored, right_v_mirrored = self.fiber_coupler_v_mirrored
        max_lines = self.max_lines
        blocks = self.blocks
        width = self.width
        spacing = self.spacing
        bend_degrees = self.bend_degrees
        default_bend_factory = self.bend_factory
        default_bend_factories = self.bend_factories
        waveguide_type = self.waveguide_type
        connection_type = self.connection_type
        device_connection_length = self.device_connection_length
        min_io_connection_length = self.min_io_connection_length

        SHORT_STRAIGHT = 0.1
        content: List[fp.ICellRef] = []
        left_x = -width / 2
        right_x = width / 2
        left_y: float = 0
        right_y: float = 0
        links: List[
            Tuple[
                Tuple[fp.IOwnedPort, fp.IOwnedPort], str, Optional[fp.IBendWaveguideFactory], Optional[Callable[[fp.IWaveguideType], fp.IBendWaveguideFactory]]
            ]
        ] = []
        total_lines = 0

        if connection_type is None:
            connection_type = waveguide_type
        for block in blocks:
            assert isinstance(block, Block)
            y = max(left_y, right_y)
            if isinstance(block, Title):
                label: Any = block.content.cell.content[0]
                distance, _ = label.size
                count = int(width / (distance + block.gap))
                labels: List[fp.IElement] = []
                for i in range(count):
                    labels.append(label.translated(-width / 2 + i * (distance + block.gap), y))
                content.append(fp.Device(name=&#34;Title&#34;, content=labels, ports=[]))
                left_y = y + spacing
                right_y = y + spacing
                continue
            if isinstance(block, Blank):
                left_y += block.left * spacing
                right_y += block.right * spacing
                continue
            block_bend_factory = block.bend_factory
            block_bend_factories = block.bend_factories
            bend_factory = block_bend_factory or default_bend_factory
            bend_factories = block_bend_factories or default_bend_factories

            device_adapter = cast(DeviceAdapter, partial(Extended, waveguide_type=waveguide_type, lengths={&#34;*&#34;: device_connection_length}))
            instance = _get_block_content(block, left_y, right_y, spacing, device_adapter)
            content.append(instance)
            left_ports = util.ports.get_left_ports(instance, reverse=True)
            right_ports = util.ports.get_right_ports(instance, reverse=True)
            for left_port in left_ports:
                left_gc_at = fp.Waypoint(left_x, left_y, 180)
                left_gc, left_gc_port = fiber_coupler_factory(at=left_gc_at, device=instance)
                if left_v_mirrored:
                    left_gc = left_gc.v_mirrored()
                left_gc_instance = left_gc if waveguide_type is None else AutoTransitioned(device=left_gc, waveguide_types={&#34;*&#34;: waveguide_type})
                left_gc_transition_length = fp.distance_between(left_gc[left_gc_port].position, left_gc_instance[left_gc_port].position)
                left_gc_instance = fp.place(left_gc_instance, left_gc_port, at=left_gc_at.advanced(-left_gc_transition_length))
                content.append(left_gc_instance)
                left_y += spacing
                turning_angle = fp.normalize_angle(math.pi - left_port.orientation)
                if fp.is_nonzero(turning_angle):
                    left_port = util.links.bend(
                        TECH,
                        content,
                        start=left_port,
                        radians=turning_angle,
                        bend_factory=bend_factory or bend_factories and bend_factories(left_port.waveguide_type),
                    )
                    left_port = util.links.straight(TECH, content, start=left_port, length=SHORT_STRAIGHT)
                links.append((left_port &lt;= cast(fp.IOwnedPort, left_gc_instance[left_gc_port]), &#34;left&#34;, bend_factory, bend_factories))

            for right_port in right_ports:
                right_gc_at = fp.Waypoint(right_x, right_y, 0)
                right_gc, right_gc_port = fiber_coupler_factory(at=right_gc_at, device=instance)
                if right_v_mirrored:
                    right_gc = right_gc.v_mirrored()
                right_gc_instance = right_gc if waveguide_type is None else AutoTransitioned(device=right_gc, waveguide_types={&#34;*&#34;: waveguide_type})
                right_gc_transition_length = fp.distance_between(right_gc[right_gc_port].position, right_gc_instance[right_gc_port].position)
                right_gc_instance = fp.place(right_gc_instance, right_gc_port, at=right_gc_at.advanced(-right_gc_transition_length))

                content.append(right_gc_instance)
                right_y += spacing
                turning_angle = fp.normalize_angle(0 - right_port.orientation)
                if fp.is_nonzero(turning_angle):
                    right_port = util.links.bend(
                        TECH,
                        content,
                        start=right_port,
                        radians=turning_angle,
                        bend_factory=bend_factory or bend_factories and bend_factories(right_port.waveguide_type),
                    )
                    right_port = util.links.straight(TECH, content, start=right_port, length=SHORT_STRAIGHT)
                links.append((right_port &lt;= cast(fp.IOwnedPort, right_gc_instance[right_gc_port]), &#34;right&#34;, bend_factory, bend_factories))
            total_lines += max(len(left_ports), len(right_ports))

        if max_lines is not None:
            assert total_lines &lt;= max_lines, f&#34;exceed max lines: {max_lines}, got: {total_lines}&#34;

        for (dev, gc), p, bend_factory, bend_factories in links:
            if p == &#34;left&#34;:
                x0, y0 = gc.position
                x1, y1 = dev.position
            else:
                x0, y0 = dev.position
                x1, y1 = gc.position

            length = x1 - x0
            height = y1 - y0

            end_type = waveguide_type
            if fp.is_nonzero(height):
                sbend_type = waveguide_type or dev.waveguide_type
                sbend = SBend(
                    height=height,
                    bend_degrees=bend_degrees,
                    max_distance=length - min_io_connection_length,
                    waveguide_type=sbend_type,
                    bend_factory=bend_factory or (bend_factories and bend_factories(sbend_type)) or sbend_type.bend_factory,
                )
                sbend_distance = abs(sbend[&#34;op_1&#34;].position[0] - sbend[&#34;op_0&#34;].position[0])
                sbend = fp.place(sbend, &#34;op_1&#34; if p == &#34;left&#34; else &#34;op_0&#34;, at=dev.position)
                content.append(sbend)
                length -= sbend_distance
                end_type = sbend_type

            util.links.straight(TECH, content, start=gc, length=length, link_type=connection_type, end_type=end_type)

        insts += content
        return insts, elems, ports</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>fnpcell.pdk.pcell.PCell</li>
<li>fnpcell.cell.cell_ref.CellRef</li>
<li>fnpcell.mixin.transform_mixin.TransformMixin</li>
<li>fnpcell.interfaces.ICellRef</li>
<li>fnpcell.interfaces.IUpdatable</li>
<li>fnpcell.interfaces.IElement</li>
<li>fnpcell.interfaces.IRunnable</li>
<li>fnpcell.interfaces.IAffineTransformable</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.bend_degrees"><code class="name">var <span class="ident">bend_degrees</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.bend_factories"><code class="name">var <span class="ident">bend_factories</span> : Optional[Callable[[fnpcell.interfaces.IWaveguideType], fnpcell.interfaces.IBendWaveguideFactory]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.bend_factory"><code class="name">var <span class="ident">bend_factory</span> : Optional[fnpcell.interfaces.IBendWaveguideFactory]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.blocks"><code class="name">var <span class="ident">blocks</span> : Sequence[<a title="gpdk.routing.comp_scan.comp_scan.Block" href="#gpdk.routing.comp_scan.comp_scan.Block">Block</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.connection_type"><code class="name">var <span class="ident">connection_type</span> : Optional[fnpcell.interfaces.IWaveguideType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.device_connection_length"><code class="name">var <span class="ident">device_connection_length</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.fiber_coupler_adapter"><code class="name">var <span class="ident">fiber_coupler_adapter</span> : Optional[fnpcell.interfaces.ICellRef]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.fiber_coupler_adapter_port"><code class="name">var <span class="ident">fiber_coupler_adapter_port</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.fiber_coupler_factory"><code class="name">var <span class="ident">fiber_coupler_factory</span> : <a title="gpdk.routing.comp_scan.comp_scan.FiberCouplerFactory" href="#gpdk.routing.comp_scan.comp_scan.FiberCouplerFactory">FiberCouplerFactory</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.fiber_coupler_v_mirrored"><code class="name">var <span class="ident">fiber_coupler_v_mirrored</span> : Sequence[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.max_lines"><code class="name">var <span class="ident">max_lines</span> : Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.min_io_connection_length"><code class="name">var <span class="ident">min_io_connection_length</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.spacing"><code class="name">var <span class="ident">spacing</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.waveguide_type"><code class="name">var <span class="ident">waveguide_type</span> : Optional[fnpcell.interfaces.IWaveguideType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.width"><code class="name">var <span class="ident">width</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScan.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self) ‑> Tuple[fnpcell.pdk.collection.InstanceSet, fnpcell.pdk.collection.ElementSet, fnpcell.pdk.collection.PortSet]</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract method must be implemented to build a pcell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self) -&gt; Tuple[fp.InstanceSet, fp.ElementSet, fp.PortSet]:
    insts, elems, ports = super().build()
    TECH = get_technology()
    fiber_coupler_factory = self.fiber_coupler_factory
    left_v_mirrored, right_v_mirrored = self.fiber_coupler_v_mirrored
    max_lines = self.max_lines
    blocks = self.blocks
    width = self.width
    spacing = self.spacing
    bend_degrees = self.bend_degrees
    default_bend_factory = self.bend_factory
    default_bend_factories = self.bend_factories
    waveguide_type = self.waveguide_type
    connection_type = self.connection_type
    device_connection_length = self.device_connection_length
    min_io_connection_length = self.min_io_connection_length

    SHORT_STRAIGHT = 0.1
    content: List[fp.ICellRef] = []
    left_x = -width / 2
    right_x = width / 2
    left_y: float = 0
    right_y: float = 0
    links: List[
        Tuple[
            Tuple[fp.IOwnedPort, fp.IOwnedPort], str, Optional[fp.IBendWaveguideFactory], Optional[Callable[[fp.IWaveguideType], fp.IBendWaveguideFactory]]
        ]
    ] = []
    total_lines = 0

    if connection_type is None:
        connection_type = waveguide_type
    for block in blocks:
        assert isinstance(block, Block)
        y = max(left_y, right_y)
        if isinstance(block, Title):
            label: Any = block.content.cell.content[0]
            distance, _ = label.size
            count = int(width / (distance + block.gap))
            labels: List[fp.IElement] = []
            for i in range(count):
                labels.append(label.translated(-width / 2 + i * (distance + block.gap), y))
            content.append(fp.Device(name=&#34;Title&#34;, content=labels, ports=[]))
            left_y = y + spacing
            right_y = y + spacing
            continue
        if isinstance(block, Blank):
            left_y += block.left * spacing
            right_y += block.right * spacing
            continue
        block_bend_factory = block.bend_factory
        block_bend_factories = block.bend_factories
        bend_factory = block_bend_factory or default_bend_factory
        bend_factories = block_bend_factories or default_bend_factories

        device_adapter = cast(DeviceAdapter, partial(Extended, waveguide_type=waveguide_type, lengths={&#34;*&#34;: device_connection_length}))
        instance = _get_block_content(block, left_y, right_y, spacing, device_adapter)
        content.append(instance)
        left_ports = util.ports.get_left_ports(instance, reverse=True)
        right_ports = util.ports.get_right_ports(instance, reverse=True)
        for left_port in left_ports:
            left_gc_at = fp.Waypoint(left_x, left_y, 180)
            left_gc, left_gc_port = fiber_coupler_factory(at=left_gc_at, device=instance)
            if left_v_mirrored:
                left_gc = left_gc.v_mirrored()
            left_gc_instance = left_gc if waveguide_type is None else AutoTransitioned(device=left_gc, waveguide_types={&#34;*&#34;: waveguide_type})
            left_gc_transition_length = fp.distance_between(left_gc[left_gc_port].position, left_gc_instance[left_gc_port].position)
            left_gc_instance = fp.place(left_gc_instance, left_gc_port, at=left_gc_at.advanced(-left_gc_transition_length))
            content.append(left_gc_instance)
            left_y += spacing
            turning_angle = fp.normalize_angle(math.pi - left_port.orientation)
            if fp.is_nonzero(turning_angle):
                left_port = util.links.bend(
                    TECH,
                    content,
                    start=left_port,
                    radians=turning_angle,
                    bend_factory=bend_factory or bend_factories and bend_factories(left_port.waveguide_type),
                )
                left_port = util.links.straight(TECH, content, start=left_port, length=SHORT_STRAIGHT)
            links.append((left_port &lt;= cast(fp.IOwnedPort, left_gc_instance[left_gc_port]), &#34;left&#34;, bend_factory, bend_factories))

        for right_port in right_ports:
            right_gc_at = fp.Waypoint(right_x, right_y, 0)
            right_gc, right_gc_port = fiber_coupler_factory(at=right_gc_at, device=instance)
            if right_v_mirrored:
                right_gc = right_gc.v_mirrored()
            right_gc_instance = right_gc if waveguide_type is None else AutoTransitioned(device=right_gc, waveguide_types={&#34;*&#34;: waveguide_type})
            right_gc_transition_length = fp.distance_between(right_gc[right_gc_port].position, right_gc_instance[right_gc_port].position)
            right_gc_instance = fp.place(right_gc_instance, right_gc_port, at=right_gc_at.advanced(-right_gc_transition_length))

            content.append(right_gc_instance)
            right_y += spacing
            turning_angle = fp.normalize_angle(0 - right_port.orientation)
            if fp.is_nonzero(turning_angle):
                right_port = util.links.bend(
                    TECH,
                    content,
                    start=right_port,
                    radians=turning_angle,
                    bend_factory=bend_factory or bend_factories and bend_factories(right_port.waveguide_type),
                )
                right_port = util.links.straight(TECH, content, start=right_port, length=SHORT_STRAIGHT)
            links.append((right_port &lt;= cast(fp.IOwnedPort, right_gc_instance[right_gc_port]), &#34;right&#34;, bend_factory, bend_factories))
        total_lines += max(len(left_ports), len(right_ports))

    if max_lines is not None:
        assert total_lines &lt;= max_lines, f&#34;exceed max lines: {max_lines}, got: {total_lines}&#34;

    for (dev, gc), p, bend_factory, bend_factories in links:
        if p == &#34;left&#34;:
            x0, y0 = gc.position
            x1, y1 = dev.position
        else:
            x0, y0 = dev.position
            x1, y1 = gc.position

        length = x1 - x0
        height = y1 - y0

        end_type = waveguide_type
        if fp.is_nonzero(height):
            sbend_type = waveguide_type or dev.waveguide_type
            sbend = SBend(
                height=height,
                bend_degrees=bend_degrees,
                max_distance=length - min_io_connection_length,
                waveguide_type=sbend_type,
                bend_factory=bend_factory or (bend_factories and bend_factories(sbend_type)) or sbend_type.bend_factory,
            )
            sbend_distance = abs(sbend[&#34;op_1&#34;].position[0] - sbend[&#34;op_0&#34;].position[0])
            sbend = fp.place(sbend, &#34;op_1&#34; if p == &#34;left&#34; else &#34;op_0&#34;, at=dev.position)
            content.append(sbend)
            length -= sbend_distance
            end_type = sbend_type

        util.links.straight(TECH, content, start=gc, length=length, link_type=connection_type, end_type=end_type)

    insts += content
    return insts, elems, ports</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScanBuilder"><code class="flex name class">
<span>class <span class="ident">CompScanBuilder</span></span>
<span>(</span><span>*, name: Optional[str] = None, fiber_coupler_factory: Optional[<a title="gpdk.routing.comp_scan.comp_scan.FiberCouplerFactory" href="#gpdk.routing.comp_scan.comp_scan.FiberCouplerFactory">FiberCouplerFactory</a>] = None, fiber_coupler_adapter: Optional[fnpcell.interfaces.ICellRef] = None, fiber_coupler_v_mirrored: Sequence[bool] = (False, False), max_lines: Optional[int] = None, width: float = 2000, spacing: float = 127, waveguide_type: Optional[fnpcell.interfaces.IWaveguideType] = None, bend_degrees: Optional[float] = None, connection_type: Optional[fnpcell.interfaces.IWaveguideType] = None, device_connection_length: float = 20, min_io_connection_length: float = 20, bend_factory: Optional[fnpcell.interfaces.IBendWaveguideFactory] = None, bend_factories: Optional[Callable[[fnpcell.interfaces.IWaveguideType], fnpcell.interfaces.IBendWaveguideFactory]] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompScanBuilder:
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        fiber_coupler_factory: Optional[FiberCouplerFactory] = None,
        fiber_coupler_adapter: Optional[fp.IDevice] = None,
        fiber_coupler_v_mirrored: Sequence[bool] = (False, False),
        max_lines: Optional[int] = None,
        width: float = 2000,
        spacing: float = 127,
        waveguide_type: Optional[fp.IWaveguideType] = None,
        bend_degrees: Optional[float] = None,
        connection_type: Optional[fp.IWaveguideType] = None,
        device_connection_length: float = 20,
        min_io_connection_length: float = 20,
        bend_factory: Optional[fp.IBendWaveguideFactory] = None,
        bend_factories: Optional[Callable[[fp.IWaveguideType], fp.IBendWaveguideFactory]] = None,
    ) -&gt; None:
        self.name = name
        self.fiber_coupler_factory = fiber_coupler_factory
        self.fiber_coupler_adapter = fiber_coupler_adapter
        self.fiber_coupler_v_mirrored = fiber_coupler_v_mirrored
        self.max_lines = max_lines
        self.width = width
        self.spacing = spacing
        self.waveguide_type = waveguide_type
        self.bend_degrees = bend_degrees
        self.connection_type = connection_type
        self.device_connection_length = device_connection_length
        self.min_io_connection_length = min_io_connection_length
        self.bend_factory = bend_factory
        self.bend_factories = bend_factories
        self.blocks = []  # type: List[Block]

    def build(self, transform: fp.Affine2D = fp.Affine2D.identity()):
        params = dict(
            name=self.name or &#34;&#34;,
            fiber_coupler_factory=self.fiber_coupler_factory,
            fiber_coupler_adapter=self.fiber_coupler_adapter,
            fiber_coupler_v_mirrored=self.fiber_coupler_v_mirrored,
            max_lines=self.max_lines,
            blocks=self.blocks,
            width=self.width,
            spacing=self.spacing,
            waveguide_type=self.waveguide_type,
            connection_type=self.connection_type,
            device_connection_length=self.device_connection_length,
            min_io_connection_length=self.min_io_connection_length,
            bend_factory=self.bend_factory,
            bend_factories=self.bend_factories,
            transform=transform,
        )
        for key, value in list(params.items()):
            if value is None:
                del params[key]
        return CompScan(**params)

    def add_block(
        self,
        content: fp.IDevice,
        *,
        offset: Tuple[float, float] = (0, 0),
        repeat: int = 1,
        bend_factory: Optional[fp.IBendWaveguideFactory] = None,
        bend_factories: Optional[Callable[[fp.IWaveguideType], fp.IBendWaveguideFactory]] = None,
    ):
        self.blocks.append(Block(content, offset=offset, repeat=repeat, bend_factory=bend_factory, bend_factories=bend_factories))

    def add_alignment(self, *, offset: Tuple[float, float] = (0, 0), waveguide_type: Optional[fp.IWaveguideType] = None):
        waveguide_type = waveguide_type or self.waveguide_type
        assert waveguide_type is not None, &#34;waveguide_type must be supplied&#34;
        self.blocks.append(Alignment(offset=offset, waveguide_type=waveguide_type))

    def add_title(self, content: str, *, gap: float = 20, font_size: float = 5, layer: fp.ILayer):
        self.blocks.append(Title(content, gap=gap, font_size=font_size, layer=layer))

    def add_blank(self, left: int = 1, right: int = 1):
        self.blocks.append(Blank(left=left, right=right))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScanBuilder.add_alignment"><code class="name flex">
<span>def <span class="ident">add_alignment</span></span>(<span>self, *, offset: Tuple[float, float] = (0, 0), waveguide_type: Optional[fnpcell.interfaces.IWaveguideType] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_alignment(self, *, offset: Tuple[float, float] = (0, 0), waveguide_type: Optional[fp.IWaveguideType] = None):
    waveguide_type = waveguide_type or self.waveguide_type
    assert waveguide_type is not None, &#34;waveguide_type must be supplied&#34;
    self.blocks.append(Alignment(offset=offset, waveguide_type=waveguide_type))</code></pre>
</details>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScanBuilder.add_blank"><code class="name flex">
<span>def <span class="ident">add_blank</span></span>(<span>self, left: int = 1, right: int = 1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_blank(self, left: int = 1, right: int = 1):
    self.blocks.append(Blank(left=left, right=right))</code></pre>
</details>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScanBuilder.add_block"><code class="name flex">
<span>def <span class="ident">add_block</span></span>(<span>self, content: fnpcell.interfaces.ICellRef, *, offset: Tuple[float, float] = (0, 0), repeat: int = 1, bend_factory: Optional[fnpcell.interfaces.IBendWaveguideFactory] = None, bend_factories: Optional[Callable[[fnpcell.interfaces.IWaveguideType], fnpcell.interfaces.IBendWaveguideFactory]] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_block(
    self,
    content: fp.IDevice,
    *,
    offset: Tuple[float, float] = (0, 0),
    repeat: int = 1,
    bend_factory: Optional[fp.IBendWaveguideFactory] = None,
    bend_factories: Optional[Callable[[fp.IWaveguideType], fp.IBendWaveguideFactory]] = None,
):
    self.blocks.append(Block(content, offset=offset, repeat=repeat, bend_factory=bend_factory, bend_factories=bend_factories))</code></pre>
</details>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScanBuilder.add_title"><code class="name flex">
<span>def <span class="ident">add_title</span></span>(<span>self, content: str, *, gap: float = 20, font_size: float = 5, layer: fnpcell.interfaces.ILayer)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_title(self, content: str, *, gap: float = 20, font_size: float = 5, layer: fp.ILayer):
    self.blocks.append(Title(content, gap=gap, font_size=font_size, layer=layer))</code></pre>
</details>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.CompScanBuilder.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self, transform: fnpcell.transform.Affine2D = Affine2D.identity())</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self, transform: fp.Affine2D = fp.Affine2D.identity()):
    params = dict(
        name=self.name or &#34;&#34;,
        fiber_coupler_factory=self.fiber_coupler_factory,
        fiber_coupler_adapter=self.fiber_coupler_adapter,
        fiber_coupler_v_mirrored=self.fiber_coupler_v_mirrored,
        max_lines=self.max_lines,
        blocks=self.blocks,
        width=self.width,
        spacing=self.spacing,
        waveguide_type=self.waveguide_type,
        connection_type=self.connection_type,
        device_connection_length=self.device_connection_length,
        min_io_connection_length=self.min_io_connection_length,
        bend_factory=self.bend_factory,
        bend_factories=self.bend_factories,
        transform=transform,
    )
    for key, value in list(params.items()):
        if value is None:
            del params[key]
    return CompScan(**params)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.ConstFiberCouplerFactory"><code class="flex name class">
<span>class <span class="ident">ConstFiberCouplerFactory</span></span>
<span>(</span><span>coupler: fnpcell.interfaces.ICellRef, port: Optional[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConstFiberCouplerFactory(FiberCouplerFactory):
    def __init__(self, coupler: fp.IDevice, port: Optional[str]):
        self.coupler = coupler
        self.port = port

    def __call__(self, at: fp.IRay, device: fp.IDevice) -&gt; Tuple[fp.IDevice, str]:
        coupler = self.coupler
        port = self.port or &#34;op_0&#34;
        return (coupler, port)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gpdk.routing.comp_scan.comp_scan.FiberCouplerFactory" href="#gpdk.routing.comp_scan.comp_scan.FiberCouplerFactory">FiberCouplerFactory</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.DeviceAdapter"><code class="flex name class">
<span>class <span class="ident">DeviceAdapter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeviceAdapter(Protocol):
    def __call__(self, device: fp.IDevice) -&gt; fp.IDevice:
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.FiberCouplerFactory"><code class="flex name class">
<span>class <span class="ident">FiberCouplerFactory</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FiberCouplerFactory(Protocol):
    def __call__(self, at: fp.IRay, device: fp.IDevice) -&gt; Tuple[fp.IDevice, str]:
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="gpdk.routing.comp_scan.comp_scan.ConstFiberCouplerFactory" href="#gpdk.routing.comp_scan.comp_scan.ConstFiberCouplerFactory">ConstFiberCouplerFactory</a></li>
</ul>
</dd>
<dt id="gpdk.routing.comp_scan.comp_scan.Title"><code class="flex name class">
<span>class <span class="ident">Title</span></span>
<span>(</span><span>content: str, *, gap: float = 20, font_size: float = 5, layer: fnpcell.interfaces.ILayer)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Title(Block):
    def __init__(
        self,
        content: str,
        *,
        gap: float = 20,
        font_size: float = 5,
        layer: fp.ILayer,
    ) -&gt; None:
        super().__init__(
            content=fp.Device(
                name=&#34;Title&#34;,
                content=[
                    fp.el.Label(
                        content,
                        font_size=font_size,
                        layer=layer,
                    ),
                ],
                ports=[],
            ),
        )
        self.gap = gap</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gpdk.routing.comp_scan.comp_scan.Block" href="#gpdk.routing.comp_scan.comp_scan.Block">Block</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="../../assets/tingle/0.15.3/tingle.min.css">
<script src="../../assets/tingle/0.15.3/tingle.min.js"></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gpdk.routing.comp_scan" href="index.html">gpdk.routing.comp_scan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gpdk.routing.comp_scan.comp_scan.Alignment" href="#gpdk.routing.comp_scan.comp_scan.Alignment">Alignment</a></code></h4>
</li>
<li>
<h4><code><a title="gpdk.routing.comp_scan.comp_scan.Blank" href="#gpdk.routing.comp_scan.comp_scan.Blank">Blank</a></code></h4>
</li>
<li>
<h4><code><a title="gpdk.routing.comp_scan.comp_scan.Block" href="#gpdk.routing.comp_scan.comp_scan.Block">Block</a></code></h4>
</li>
<li>
<h4><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan" href="#gpdk.routing.comp_scan.comp_scan.CompScan">CompScan</a></code></h4>
<ul class="">
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.bend_degrees" href="#gpdk.routing.comp_scan.comp_scan.CompScan.bend_degrees">bend_degrees</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.bend_factories" href="#gpdk.routing.comp_scan.comp_scan.CompScan.bend_factories">bend_factories</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.bend_factory" href="#gpdk.routing.comp_scan.comp_scan.CompScan.bend_factory">bend_factory</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.blocks" href="#gpdk.routing.comp_scan.comp_scan.CompScan.blocks">blocks</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.build" href="#gpdk.routing.comp_scan.comp_scan.CompScan.build">build</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.connection_type" href="#gpdk.routing.comp_scan.comp_scan.CompScan.connection_type">connection_type</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.device_connection_length" href="#gpdk.routing.comp_scan.comp_scan.CompScan.device_connection_length">device_connection_length</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.fiber_coupler_adapter" href="#gpdk.routing.comp_scan.comp_scan.CompScan.fiber_coupler_adapter">fiber_coupler_adapter</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.fiber_coupler_adapter_port" href="#gpdk.routing.comp_scan.comp_scan.CompScan.fiber_coupler_adapter_port">fiber_coupler_adapter_port</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.fiber_coupler_factory" href="#gpdk.routing.comp_scan.comp_scan.CompScan.fiber_coupler_factory">fiber_coupler_factory</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.fiber_coupler_v_mirrored" href="#gpdk.routing.comp_scan.comp_scan.CompScan.fiber_coupler_v_mirrored">fiber_coupler_v_mirrored</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.max_lines" href="#gpdk.routing.comp_scan.comp_scan.CompScan.max_lines">max_lines</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.min_io_connection_length" href="#gpdk.routing.comp_scan.comp_scan.CompScan.min_io_connection_length">min_io_connection_length</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.spacing" href="#gpdk.routing.comp_scan.comp_scan.CompScan.spacing">spacing</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.waveguide_type" href="#gpdk.routing.comp_scan.comp_scan.CompScan.waveguide_type">waveguide_type</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScan.width" href="#gpdk.routing.comp_scan.comp_scan.CompScan.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gpdk.routing.comp_scan.comp_scan.CompScanBuilder" href="#gpdk.routing.comp_scan.comp_scan.CompScanBuilder">CompScanBuilder</a></code></h4>
<ul class="">
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScanBuilder.add_alignment" href="#gpdk.routing.comp_scan.comp_scan.CompScanBuilder.add_alignment">add_alignment</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScanBuilder.add_blank" href="#gpdk.routing.comp_scan.comp_scan.CompScanBuilder.add_blank">add_blank</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScanBuilder.add_block" href="#gpdk.routing.comp_scan.comp_scan.CompScanBuilder.add_block">add_block</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScanBuilder.add_title" href="#gpdk.routing.comp_scan.comp_scan.CompScanBuilder.add_title">add_title</a></code></li>
<li><code><a title="gpdk.routing.comp_scan.comp_scan.CompScanBuilder.build" href="#gpdk.routing.comp_scan.comp_scan.CompScanBuilder.build">build</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gpdk.routing.comp_scan.comp_scan.ConstFiberCouplerFactory" href="#gpdk.routing.comp_scan.comp_scan.ConstFiberCouplerFactory">ConstFiberCouplerFactory</a></code></h4>
</li>
<li>
<h4><code><a title="gpdk.routing.comp_scan.comp_scan.DeviceAdapter" href="#gpdk.routing.comp_scan.comp_scan.DeviceAdapter">DeviceAdapter</a></code></h4>
</li>
<li>
<h4><code><a title="gpdk.routing.comp_scan.comp_scan.FiberCouplerFactory" href="#gpdk.routing.comp_scan.comp_scan.FiberCouplerFactory">FiberCouplerFactory</a></code></h4>
</li>
<li>
<h4><code><a title="gpdk.routing.comp_scan.comp_scan.Title" href="#gpdk.routing.comp_scan.comp_scan.Title">Title</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
</footer>
</body>
</html>